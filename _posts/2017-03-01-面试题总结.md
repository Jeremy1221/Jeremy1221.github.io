===
最高阶标题
===

---
title: The interview questions summary
description: This is an introduction to summary of interview questions
#header: 面试总结
---

工作两年多，依然对面试中的技术感到手足无措，从大学后一直玩物丧志，所以接下来从面试题中学习来弥补之前的堕落。这篇文章将要写很长。

* MVC设计模式：

M：model数据源： 负责存储，定义，操作数据
V：view展示给用户看，负责与用户的交互
C：controller可以和m和v直接通信，v要通过代理来和c通信，m通过kvo或nsnotification和c通信，m和v不能直接通信。c负责将m的数据交给v使用。
在这里对MVC、MVP、MVVM最一下简单的比较:
MVC:v和c的耦合度很高，业务逻辑代码会被分散到ui布局代码中，不利于单元测试。c很臃肿。但是维护可开发成本小。
MVP:这里的v=c，将主要的任务分散到m和p中，v的功能很少，测试变的很简单，开发时间增加，代码量是mvc的两倍。
MVVM:vm=viewmodel，v=c，v承担的责任比mvp中的v多一点。更加容易单元测试，如果使用绑定，成本貌似比mvp小。
还有一种VIPER架构，hin复杂。不加说明。

* 循环引用:

![retain_cycle_1](https://Jeremy1221.github.io/img/retain_cycle/retain_cycle_1.png)

我的理解：对象A和B互相持有，当我们想要销毁A时，因为A持有B，然后我们回去尝试销毁B，此时我们发现B又持有A，然后我们有尝试去销毁B。如此循环下来我们就没法销毁任何一个。

![retain_cycle_2](https://Jeremy1221.github.io/img/retain_cycle/retain_cycle_2.png)

如果多个对象之间存在这个问题，对象越多，环越大，就越难发现这个问题。

* 线程与进程

一个程序只有一个进程，一个进程可以有多个线程。
进程是*资源*分配的最小独立单元
一个线程死了，这个进程就死了，但是进程间没有这个问题，因为进程有自己的独立地址空间，所以进程比较安全，但是进程间切换消耗资源大，效率差。
要求同时进行并且共享资源的时候只能用线程，不能用进程。进程也可以共享资源，但是不能同时进行。

* LayoutSubViews在什么时候被调用？

当View本身的frame改变时，会调用这个方法。

* loadView

controller的view为nil时会调用，viewDidLoad在view从nib文件初始化时调用

* __block和__weak

不想再了解了，因为现在主要在学习swift。

* 堆和栈

栈区是由系统自行管理的，堆是程序员来管理的
栈是连续的，堆是不连续的所以会产生碎片
堆是动态分配，栈是动态和静态分配的
栈的分配效率比堆高

* xml解析

dom和sax dom处理规模较大的文档是很耗内存占用资源比较多

* _objc_msgForward函数是做什么的，直接调用它将会发生什么？

用来做消息转发，如果一个对象并没有实现一个方法，那么这个方法将会尝试转发消息，调用过程会涉及到五个方法

1. resolveInstanceMethod:
2. forwardingTargetForSelector:
3. methodSignatureForSelector:
4. forwardInvocation:
5. doesNotRecognizeSelector: 

如果直接调用会跳过这五个方法。如果转发的对象没有实现这个方法。将会直接崩溃。先send后forward[这里说的好详细啊](http://www.cocoachina.com/ios/20150825/13195.html)

* 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？

不能向编译后得到的类中增加实例变量；能向运行时创建的类中添加实例变量；原因如下：因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；

运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。

* applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。
* 如何终止正在运行的工作线程？
* instrument
* 如何自己高效实现NSUserDefault?

看到这个题目是一个群里的朋友发的，感谢那个兄弟，看到MrPeak大大出的题目啊 好开心，试着答，各位大大请轻喷，刚好不怎么忙，带着耳机听歌，答了一个小时，真舒服啊，看到这些题目好多都不怎么知道，恶补，学习。

* NSString如何计算字符的个数？

应该是用countElements的函数来统计字符串所包含的字符个数，把参数为要统计的字符串就好了。

但是需要注意以下的几个点：

1. 因为不同的Unicode字符，同样的字符不同的编码都可能导致占用不同的内存。所以按正常来说，字符串中的每个字符会占用不同的内存。因此，只能通过遍历字符串中的每个字符来计算字符串的长度。但是当在处理一个特别长的字符串的话，可以通过遍历遍历整个字符串，这样既可以算出字符串的长度了。

2. 同一个字符串，countElements计算出来的字符个数与NSString的length计算出来的长度也不一定总是一样的的。因为NSString的长度是基UTF-16编码的编码来计算的，而不是Unicode编码的个数。但是，好像在Swift中可以使用字符串的utf16count属性来来获得原来NSString的length值，忘记了，很久没用Swift了。

* PKI体系当中加密和签名有什么区别？

这个问题我来答的话，应该先说说PKI是一种安全技术, 数字签名和加密基本原理是什么，在说区别，话说基本原理我也不记得了，就大概记得一个HUSH函数什么的了，他们的过程都是使用公开密钥体系，但实现的过程是不同的，相反，使用的密钥对也不同。

1. 数字签名是发送方的密钥对，发送方用自己的私有密钥进行加密，接收方用发送方的公开密钥进行解密，大致就是这样吧，它一个一对多的关系，任何拥有发送方公开密钥的人都可以验证数字签名的正确性，还有只采用了非对称密钥加密算法,能保证发送信息的完整性、身份认证和不可否认性。

2. 数字加密是接收方的密钥对，这是多对一的关系，任何知道接收方公开密钥的人都可以向接收方发送加密信息，只有唯一拥有接收方私有密钥的人才能对信息解密,用的对称密钥加密算法和非对称密钥加密算法相结合的方法，它能保证发送信息保密性。

* 如何自己高效实现NSUserDefault?

这个，真心不知道，peak大大。只知道NSUserDefaults是定时把缓存中的数据写入磁盘的，而不是即时写入，为了防止在写完NSUserDefaults后程序退出导致的数据丢失，可以在写入数据后使用synchronize强制立即将数据写入磁盘，现在要高效的实现NSUserDefaults，个人见解就是不频繁的使用synchornize，自定义一个类，在存取时通过NSData做载体。

* 解释下tcp的慢启动特性。

现在公司应该都是在避免慢启动，做性能优化吧，优化应该可以尽量把大量小文件放在一个TCP连接中排队传输吧，没试验过，自己YY的。

这问的是Tcp慢启动的特点，难道就是它在新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量，但是这样的话 性能呢，请科普下，谢谢。

* 如何用HTTP实现长连接？

首先HTTP是无状态的，要维持一个长连接可以用心跳包啊，公司项目第一个版本就是这样用的，然后各种原因，各种呵呵呵，丢包，沾包，应该可以对http连接进行轮询，但是http定时轮询会存在延迟 用户体验就不好了 或者用socket流方法，监听服务器消息

* HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？

不一定的，一个页面由html、css、js、图片组成，连接数要看具体页面资源的大小和服务器端的配置。

* 数据库建表的时候索引有什么用？

创建索引可以大大提高系统的性能，加快数据的检索速度，加速表和表之间的连接，保证数据库表中每一行数据的唯一性，但是有些列不应该创建索引，这又要考虑到性能了，所以具体情况具体分析了。

* Full Text Search为什么快？

这我不是后台不是很了解，问题偏后台系统多一点点了，但是自己会写一点点PHP，好像是用空间来换时间,通过分词器，降索引的表分割啥的，不是很清楚原理啊，看来要系统学下后台语言。

* iOS下如何实现指定线程数目的线程池？

这个问题问的太深了吧，一般开发根本用不到，还好最近在看线程安全方面的书籍，要不然问到真的会懵逼。

1.循环通过pthread_create创建线程，创建s_tfthread对象做为线程句，加入线程数组,s_tftask_content->methord初始化为空函数

2.创建任务执行函数，执行完通过task初始化函数后，在执行函数中通过pthread_cond_wait信号将当前创建的线程挂起

3.创建完之后，程序中将会有n个挂起状态的线程，当需要执行新的task的时候查找，我们就可以根据不同的task标志在k_threads中查询出空闲线程，并创建新的s_tftask_content加入s_tfthread的任务列表，通过pthread_cond_signal重新唤醒该线程继续执行任务

* 介绍下iOS设备获取唯一设备号的历史变迁。

这个没做过几年开发的真心不知道，iOS中获取设备唯一标示符的方法一直随版本的更新而变化。iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，但是好像是iOS 4还是iOS5就被苹果废弃掉了，然后iOS6是用WiFi的mac地址来获取的，iOS7后大家都知道了，主要是由于苹果又坑爹了，封杀mac地址，但是推荐大家用KeyChain来保存获取到的UDID，因为APP删了再装回来，也可以从KeyChain中读取回来，哈哈，公司的项目都是把UDID存在KeyChain。

* 函数式编程当中的 first-class function是什么意思呢？

这个问题好像以前就在知乎看过，就是类型，定义了一个可以操作的取值的集合，就像C语言的int类型一样，可进行加减乘除等操作，但是它的设计又有一个模块复用和访存控制,这样设计的原因应该是让我们更好用吧，没有深究过这个。

* 如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？

做到这里在电脑码字快三十分钟了啊，peak大大，你问的问题都好难回答啊，要分各种情况。这题也是首先要考虑 hook是否有公开头文件的类，有的话写一个Utility函数，再使用category，没有的话就建一个类作为新函数载体，然后先为被hook的类增加函数，再替换，没错就是这个样子。后面如何h如何hook某个instance的方法，应该可以定义一个函数指针变量，hook时将要调用的地址赋给这个变量，调用时把这个变量当作函数来用就行了。

* 谈下Objective C都有哪些锁机制，你一般用哪个？

synchronized、NSLOCK、GCD、递归锁、分布锁、同步锁（这个是C语言的），一般用GCD，这里就不说了，真心不想码字了，peak大大可能会问，为什么，又要把各种锁机制对比，这我会疯，我脑袋要死机了，重启中…

* 聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。

http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，刚好公司上个项目都用了这四种方式的请求，怎么都是踩过得坑。

form-urlencoded是默认的mime内容编码类型，是通用的，但是它在传输比较大的二进制或者文本数据时效率极低。

multipart/form-data是当上传文件或者二进制数据和非ASCII数据使用。

* 让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？

这个问题没有考虑过，都是自己写单元测试什么的来测试，都是些基础的测试，一般都是用Instrument来测试一些东西的。自己设计的话，主要还是要考虑一个VC的生命周期。

* 通过[UIImage imageNamed:]生成的对象什么时候被释放？

应该是到@autoreleasepool 结束的时候才释放的，但是我都是用这imageWithContentsOfFile方法加载图片的

* applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。

推送、做支付的时候，跳到人家运用，后台杀进程的时候、做IM的时候、第三方授权分享登录回调情况下等等

* 如何终止正在运行的工作线程？

在线程中调用exit、pthread_exit、pthread_kill、pthread_cance都行吧

* 穷举iOS下所有的本地持久化方案。

沙盒

plist文件（属性列表）

preference（偏好设置）

NSKeyedArchiver（归档）

SQLite 3

CoreData
>应用里有哪几个文件夹，iTunes会保存的是哪个文件夹

>Application: 

>Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。

>Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。

>Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。

>tmp:

* 如果公司强制996，你有什么心里话要对老板说吗？

没什么话，习惯了，主要想要对产品经理说你的需求能不能想好在做，不要瞎搞，谢谢

* 如何应对APP版本升级，数据结构随之变化?

自己接触的Sqlite相对多一些，通常的作法是重命名旧版数据库文件->创建新版本表格->导入旧版本数据->删除旧版本表
跨版本升级的问题，数据库更新的相关操作不做合并，依次迭代更新
Core data接触不多，大部分改动都在轻量化迁移支持范围内，复杂的需要重写指定映射关系

* 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。）

drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。

这个方法的主要作用是根据传入的 rect 来绘制图像 参见文档. 这个方法的默认实现没有做任何事情, 我们可以在这个方法中使用 Core Graphics 和 UIKit 来绘制视图的内容.

这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前图层标记为 dirty, 但还是会显示原来的内容, 直到下一次的视图渲染周期, 才会为标记为 dirty 的图层重新建立 Core Graphics 上下文, 然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制.

相关参考:[UIView的layoutSubviews和drawRect方法何时调用](http://xyxdasnjss.iteye.com/blog/1827954)

* 使用atomic一定是线程安全的吗？

不是，atomic的本意是指属性的存取方法是线程安全的（thread safe)，并不保证整个对象是线程安全的。比如，声明一个NSMutableArray的原子属性stuff，此时self.stuff 和self.stuff = othersulf都是线程安全的。但是，使用[self.stuff objectAtIndex:index]就不是线程安全的，需要用锁来保证线程安全性。

[知乎面试题答案1](http://www.jianshu.com/p/262c1f8b7461)[知乎面试题答案2](http://blog.csdn.net/hanangellove/article/details/45033453)

Follow your heart, but take your brain with you.


###Categories
Categories can be used to declare either instance methods or class methods but are not usually suitable for declaring additional properties. It's valid syntax to include a property declaration in a category interface, but it's not possible to declare an additional instance variable in a category. This means the compiler won't synthesize any instance variable, nor will it synthesize any property accessor methods. You can write your own accessor methods in the implementation, but you won't be able to track for that property unless it's already stored by the original class.

The only way to add a additional property-backed by a new instance variable-to an existing class is to use a class extension, as decribed in [Class Extensions Extend the Internal Implementation](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW3)

###Use Class Extensions to Hide Private Information



#Write it on your heart that every day is the best day in the year

#2018.08.21
#new interview test

1. 说一下OC的反射机制
2. block的实质是什么？有几种block？分别是怎样产生的？
3. __block修饰的变量为什么能在block里面改变其值
4. 说一下线程之间的通信
5. 你们app的崩溃率是多少？
6. 说一下hash算法
7. NSDicitionary的实现原理是什么
8. 你们的app是如何处理本地数据安全的(比如用户名和密码)
9. 遇到过BAD_ACCESS的错误吗？你是怎样调试的
10. 什么事指针常量和常量指针
11. 不借用第三个变量，如何交换两个变量的值？要求手动写出交换的过程。
12. 如你去设计一个通知中心，你会怎样设计？
13. 如何设计一个方案去应对后端频繁更改的字段接口？
14. KVO KVC的原理
15. 用递归算法求1到n的和
16. category为什么不能添加属性
17. 说一下runloop和线程的关系
18. 说一下autoreleasePool的实现原理
19. 说一下简单工厂模式，工厂模式以及抽象工厂模式
20. 如何设计一个网络请求库
21. 说一下多线程你平常是怎么用的
22. 说一下UITableViewCell的卡顿你是怎么优化的
23. 看过哪些三方库？说一下实现的原理以及好在哪里
24. 说一下HTTP协议以及经常使用的code码的含义
25. 设计一套缓存策略
26. 设计一个检测主线程和卡顿的方案
27. 说一下runtime，工作是如何使用的看过runtime源码吗
28. 说几个你在工作中使用到的线程安全的例子。
29. 用过哪些锁？哪些锁的性能比较高
30. 说一下http和https的请求过程
31. 说一下tcp和udp
32. 说一下静态库和动态库的区别
33. load和initialize方法分别在什么时候调用
34. NSNotificationCenter是在哪个线程发送的通知
35. 用过swift吗？
36. 说一下你对架构的理解
37. 为什么一定要在主线程里面更新UI

* ##1. 说下OC的反射机制

[viewController class];
NSStringFromSelector
NSSelectorFromString
NSStringFromClass
NSClassFromString
NSStringFromProtocol
NSProtocolFromString
isKindOfClass
isMemberOfClass
conformsToProtocol
respondsToSelector

* ##2.block的实质是什么，有几种block，分别是怎样产生的
* ##3.__block修饰的变量为什么能在block里面改变其值
* ##4.说一下线程之间的通信
* ##5.你们的app崩溃率是多少
* ##6.说一下hash算法
* ##7.NSDictionary的实现原理
* ##8.你们的app是如何处理本地数据安全的(比如用户名和密码)
* ##9.遇到过BAD_ACCESS的错误吗，你是怎样解决的
* ##10.什么是指针常量和常量指针
* ##11.不使用第三个变量，如何交换两个变量的值，
* ##12.如果设计一个通知中心你会怎样设计
* ##13.如何设计一个方案去应对后端频繁更改的字段接口
* ##14.KVO和KVC的原理
* ##15.用递归算法求1到n的和
* ##16.category为什么不能添加属性
* ##17.说一下runloop个线程的关系
* ##18.说一下autoreleasepool的实现原理
* ##19.说一下简单工程模式、工厂模式和抽象工厂模式
* ##20.如何设计一个网络请求库
* ##21.说一下多线程你平常是怎么用的？
* ##22.说一下UITableViewCell的卡顿你是怎么优化的？
* ##23.看过哪些三方库？说一下实现的原理以及好在哪里？
* ##24.说下http协议经常使用code码的含义
* ##25.设计一套缓存策略
* ##26.设计一个检测主线程卡顿的方案
* ##27.说一下runtime，工作是如何使用的，看过源码吗
* ##28.说几个你在工作中使用到的线程安全的例子
* ##29.用过哪些锁？哪些锁的性能比较高?
* ##30.说一下http和https的请求过程
* ##31.说一下tcp和udp
* ##32.说一下静态库和动态库的区别
* ##33.load和initialize分别在什么时候调用
* ##34.NSNotificationCenter是在哪个线程发送的通知
* ##35.用过swift吗？
* ##36.说一下你对架构的理解
* ##37.为什么一定要在主线程中更新UI

程序一开始就进入了主线程

#new interview test 2

1. 风格就错题
2. 优化部分
3. 硬伤部分
4. 什么情况使用weak关键字相比assign有什么不同
5. 怎么用copy关键字
6. 这个写法会出什么问题:@property (copy) NSMutableArray * array;
7. 如何让自己的类用copy修饰符？如何重写带copy关键字的setter？
8. @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的
9. @protocol和category中如何使用@property
10. runtime如何实现weak属性
11. @property中有哪些属性关键词
12. weak属性需要在dealloc中置为nil么？
13. @synthesize和@dynamic分别有什么作用？
14. ARC下，不显示指定任何属性关键词时，默认的关键词都有哪些？
15. 用@property声明的NSString(或NSSArray，NSDictionary)经常使用copy关键字，为什么呢？如果改用strong关键词，可能造成什么问题
16. 对非集合类的对象的copy操作
17. 集合类对象的copy与mutablecopy
18. @synthesize合成实例变量的规则是什么？加入property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量吗？
19. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景
20. objc中向一个nil对象发送消息将会发生什么
21. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系
22. 什么会调用unrecognized selector的异常
23. 一个objc对象如何进行内存布局(考虑有父类的情况)
24. 一个objc对象的isa指针指向什么？有什么作用
25. 下面的代码输出什么？
		
		@implementation Son: Father
		- (id)init {
			self = [super init];
			if (self) {
				NSLog(@"%@", NSStringFromClass([self class]));		NSLog(@"%@", NSStringFromClass([super class]));
			}
		}
		

* ##1.风格纠错题
	
		typedef enum {
			UserSex_Man,
			UserSex_Woman,
		}UserSex;
		
		@interface UserModel: NSObject
		
		@property(nonatomic, strong) NSString * name;
		@property(assign, nonatomic) int age;
		@property(nonatomic, assign) UserSex	sex;
		
		- (id)initUserModelWithUserName:(NSString *)name WithAge:(int)age;
		- (void)doLogin;
		
		@end

修改完成后的代码:

	typedef NS_ENUM(NSUInteger, UCNSex) {
		UCNSexMale,
		UCNSexFemale,
	}
	
	@interface UCNUsermodel: NSObject 
	
	@property(nonatomic, copy) NSString * name;
	@property(nonatomic, assign) int age;
	@property(nonatomic, assign) UCNUserSex sex;
	
	- (instancetype)initWithName:(NSString *)name age:(int)age sex:(UCNUserSex)sex;
	
	+ (instancetype)userWithName:(NSString *)name age:(int)age sex:(UCNUserSex)sex;
	
	@end

优化部分 
1. enum建议用NS_ENUM和NS_OPTIONS
2. 大型项目避免冲突加上前缀
3. doLogIn不应写在模型类里
4. doLogIn命名方法不规范login是名词LogIn是动词
5. 不要用连续多个with
6. NSString用copy(非绝对但是一般情况下是这样的)
7. 初始化也要加上sex
8. assign和nonatomic换位置

硬伤部分
1. -和(void)之间应该有一个空格
2. enum中驼峰命名法和下划线命名法混用
3. enum左括号前加一个空格，或者将左括号换到下一行
4. enum右括号后加一个空格
5. UserModel :NSObject右边少一个空格
6. etc

* ##2.什么情况使用weak关键字，相比assign有什么不同

1. 在arc中，防止循环引用
2. xib storyboard中
3. weak表示非拥有关系既不保留新值也不释放旧值、自动置空
4. assign用于非OC对象 weak必须用于OC对象

* ##3.怎么用copy关键词

1. NSString NSArray NSDictionary 因为他们有对应可变类型
2. block

block使用copy是MRC遗留下来的问题 局部变量block是放在栈区的copy可以把它放到堆区。在ARC中不写也是可以的。但写上会时刻提醒我们编译器自动对block进行了copy操作。比如下面的操作不写也行。

	@property(nonatomic, copy) NSString * name;
	
	- (instancetype)initWithName:(NSString *)name {
		self = [super init];
		if (!self) {
			return nil;
		}
		_name = [name copy];
		return self;
	}

* ##4.这个写法会出什么问题 @property (copy)NSMutableArray * array;

1. 添加、删除、修改、数组内的元素会因找不到方法而崩溃，因为copy就是复制一个不可变NSArray的对象
2. 使用了atomic会严重影响性能问题。

* ##5.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？

1. 需要声明该类遵从NSCopying协议
2. 实现NSCopying协议，该协议只有一个方法:

		- (id)copyWithZone:(NSZone *)zone;

如何重写带copy关键字的setter

	- (void)setName:(NSString *)name {
		_name = [name copy];
	}

* ##6.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的

@proterty = ivar + getter + setter

property在runtime中时obj\_property\_t定义如下:

	typedef struct objc_property * obj_property_t;

而objc_property是一个结构头，包括name和attributes，定义如下:

	struct property_t {
		const char *name;
		const char *attributes;
	}

而attributes本质上是objc\_property\_attribute\_t,定义了property的一些属性，定义如下:

///Defines property attribute
typdedef struct {
	const char * name;		/**<The name of the attribute*/
	const char * value;		/**<The value of the attribute (usually empty)*/
} objc_property_attribute_t;

而attributes的具体内容是什么呢？其实，包括:类型、原子性，内存语义和对应的实例变量。

例如:我们定义一个string的property

	@property(nonatomic, copy)NSString * string;
,通过

	property_getAttributes(property)
获取到attributes并打印出来之后的结果为

	T@"NSString",C,N,V_string
其中T就代表类型，可参阅[Type Encoding](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1)，C代表copy，N代表nonatomic，V代表实例变量。

ivar、getter、setter是如何生成并添加到这个类中的？
>自动合成(autosynthesis)

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做"自动合成",这个过程是编译器在编译期执行，所以看不到任何源码。除了自动生成方法代码getter、setter之外，编译器还要自动向类中添加适当类型的实例变量。我的理解是property做了上述源码做的事这时候并没有将实例变量加入到类中，随后在编译期由编译器加入了类中。

我为了搞清楚属性是怎么实现的，曾今反编译过相关的代码，他大致生成了五个东西
1. OBJC_IVAR_$类名$属性名称:该属性的偏移量(offset)，这个偏移量是硬编码(hardcode)表示该变量距离存放对象的内存区域的起始地址有多远。
2. setter和getter方法对应的实现函数
3. ivar_list：成员变量列表
4. method_list： 方法列表
5. prop_list: 属性列表

也就是说我们每次增加一个属性，系统都会在ivar_list中添加一个成员变量的描述，在method_list中添加setter与getter方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出setter与getter方法对应的实现，在setter方法中偏移量的位置开始赋值，在getter方法中从偏移量开始取值，为了能够读取正确字节数，系统对象偏移量的指针类型进行了类型强转。

* ##7.@protocol和category中如何使用@property

在protocol和category中只会生成setter和getter方法声明，如果我们在category中需要增加属性的实现，需要借助运行时的两个函数:objc_setAssociatedObject和objc_getAssociatedObject

* ##8.runtime如何实现weak属性

runtime如何实现weak变量的自动置nil？
>runtime对注册的类，会进行布局，对于weak对象会放入一个hash表中。用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，加入weak指向的对象内存地址是a，那么就会以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。

(注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放吗？》里给出的“对象的内存销毁时间表”也提到__weak引用的解除时间。)
先看一下runtime里源码的实现：

	/**
	* The internal structure stored in the weak references table.
	* It maintains and stores
	* a hash set of weak references pointing to an object.
	* If out_of_line==0, the set is instead a small inline array.
	*/
	#define WEAK_INLINE_COUNT 4
	struct weak_entery_t {
		DisguisedPtr<objc_object> referent;
		union {
			struct {
				weak_referrer_t * referrers;
				uintptr_t				out_of_line : 1;
				uintptr_t				num_refs : PTR_MINUS_1;
				uintptr_t				mask;
				uintptr_t				mas_hash_displacement;
			};
			struct {
				//out_of_line=0 is LSB of one of these (don't care which)
				weak_referrer_t inline_referrers[WEAK_INLINE_COUNT];
			};
		};
	};
	
	/**
	* The global weak referrences table. Stores object ids as keys,
	* and weak_entry_t structs as their values.
	*/
	
	struct weak_table_t {
		weak_entry_t * weak_entries;
		size_t num_entries;
		uintptr_t mask;
		uintptr_t mas_hash_displacement;
	};

具体完整实现参照[objc/objc-weak.h](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h)。
我们可以设计一个函数(伪代码)来表示上述机制:

objc_storeWeak(&a, b)函数:

objc_storeWeak函数把第二个参数--赋值对象(b)的内存地址作为键值key，将第一个参数--weak修饰的属性变量(a)的内存地址(&a)作为value，注册到weak表中。如果第二个参数(b)为0(nil)，那么(a)的内存地址(&a)从weak表中删除，你可以把objc_storeWeak(&a, b)理解为:objc_storeWeak(value, key), 并且当key变nil，将value置nil。
在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃:在Objective-C中向nil发送消息是安全的。

而如果a是由assign修饰的，则:在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。

下面我们将基于objc_storeWeak(&a, b)函数，使用伪代码模拟"runtime如何实现weak属性":

	//使用伪代码模拟: runtime如何实现weak属性
	//http://weibo.com/luohanchenyilong/
	//https://github.com/ChenYilong
	
	id obj1;
	objc_initweak(&obj1, obj);
	/*obj引用计数变为0，变量作用域结束*/
	objc_destoryWeak(&obj1);

下面对用到的两个方法objc_initWeak和objc_destoryWeak做下解释：
总体来说，作用是: 通过objc_initWeak函数初始化"附有weak修饰符的变量(obj1)", 在变量作用域结束时通过objc_destoryWeak函数释放该变量(obj1)。

下面分别介绍下方法的内部实现:objc_initWeak函数的实现是这样的:在将"附有weak修饰符的变量(obj1)"初始化为0(nil)后，会将"赋值对象"（obj）作为参数，调用objc_storeWeak函数。

ojb1 = 0;
obj_storeWeak(&obj1, obj);
也就是说:
>weak修饰的指针默认值是nil

然后obj_destoryWeak函数将0(nil)作为参数，调用objc_storeWeak函数。objc_storeWeak(&obj1, 0);前面的源代码与下列源代码相同。

	// 使用伪代码模拟:/ runtime如何实现weak属性
	// http://weibo.com/luohanchenyilong/
	// https://github.com/ChenYilong
	
	id obj1;
	obj1 = 0;
	objc_storeWeak(&obj1, obj);
	/*... obj的引用计数变为0，被置nil...*/
	objc_storeWeak(&obj1, 0);

objc_storeWeak函数把第二个参数--赋值对象(obj)的内存地址作为键值，将第一个参数--weak修饰的属性变量(obj1)的内存地址注册到weak表中。如果第二个参数(obj)为0(nil)，那么把变量(obj1)的地址从weak表中删除，在后面的相关一题会详解。

使用伪代码是为了方便理解，下面我们"真枪实弹"的实现下:
>如何不使用weak修饰的@property，拥有weak的效果

我们从setter方法入手:
（注意以下的cyl_runAtDealloc方法实现仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可是使用CocoaPods在项目中使用[CYLDeallocBlockExecutor](https://github.com/ChenYilong/CYLDeallocBlockExecutor)）

	- (void)setObject:(NSObject *)object {
		objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
		[objcet cyl_runAtDealloc:^ {
			_object = nil;
		}];
	}

也就是有这两个步骤:

1. 在setter方法中做如下设置:

		objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);

2. 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助runtime：

		// 要摧毁的对象
		id objectToBeDeallocted;
		// objectWeWantToBeReleasedWhenThatHappens;
		objc_setAssociatedObject(objectedToBeDeallocted, someUniqueKey, objectWeWantToBeReleasedWhenThatHappens, OBJC_ASSOCIATION_RETAIN);

知道了思路，我们就开始实现cyl_runAtDealloc方法，实现过程分两部分:

第一部分：创建一个类，可以理解为一个"事件":当目标对象摧毁时，同时要发生的"事件"。借助执行"事件"。
//.h文件

	// .h文件
	// http://weibo.com/luohanchenyilong/
	// https://github.com/ChenYilong
	// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。
	
	typedef void (^voidBlock)(void);
	
	@interface CYLBlockExecutor : NSObject
	
	- (id)initWithBlock:(voidBlock)block;
	
	@end	

//.m文件

	// .m文件
	#import "CYLBlockExecutor.h"
	@interface CYLBlockExecutor() {
		voidBlock _block;
	}
	
	@implementation CYLBlockExecutor
	
	- (id)initWithBlock:(voidBlock)aBlock {
		self = [super init];
		if (self) {
			_block = [aBlock copy];
		}
		return self;
	}
	
	- (void)dealloc {
		_block ? _block() : nil;
	}
	
	@end

第二部分：核心代码：利用runtime实现cyl_runArDealloc方法

	// CYLNSObject+RunAtDealloc.h文件
	//	利用runtime实现cyl_runAtDealloc方法
	
	#import "CYLBlockExecutor.h"
	
	const void * runArDeallocBlockKey = &runAtDeallocBlockKey;
	
	@interface NSObject （CLYRunAtDealloc）
	
	- (void)cyl_runAtDealloc:(voidBlock)block;
	
	@end
	
	//CYLNSObject+RunAtDealloc.m文件
	
	#import "CYLNSObject_RunAtDealloc.h"
	#import "CYLBlockExecutor.h"
	
	@implementation NSObject (CYLRunAtDealloc)
	
	- (void)cyl_runAtDealloc:(voidBlock)block {
		if (block) {
			CYLBlockExecutor * executor = [[CYLBlockExecutor alloc] initWithBlock:block];
			
			objc_setAssociatedObject(self, runAtDeallocBlockKey, executor, OBJC_ASSOCIATION_RETAIN);
		}
	}
	
	@end
		
* ##9.@property中有哪些属性关键词
	
如果需要定义一个init开头的属性，但默认生成的setter和getter方法也会以init开头，而编译器会把所有init开头的方法当成初始化方法，而初始化方法只能返回self类型，因此编译器会报错(copy new同理):

	@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:) NSString * initBy;

另外也可以用关键字进行特殊说明，来避免编译器报错:

	@property(nonatomic, readwrite, copy, null_resettable) NSString * initBy;
	- (NSString *)initBy __attribute__((objc_method_family(none)));
	
注意：很多人会认为如果属性具备nonatomic特质，则不使用“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下：

	static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) {
		if (offset == 0) {
			object_setClass(self, newValue);
			return;
		}
		
		if oldValue;
		id *slot = (id *)((char *)self + offset);
		if (copy) {
			newValue = [newValue copyWithZone:nil];
		} else if (mutableCopy) {
			newValue = [newValue mutableCopyWithZone:nil];
		} else if () {
			if (*slot == newValue) return;
			newValue = objc_retain(newValue);
		}
		
		if (!atomic) {
			oldValue = *slot;
			*slot = newValue;
		} else {
			spinLock_t& slotLock = PropertyLocks[slot];
			slotlock.lock();
			oldValue = *slot;
			*slot = newValue();
			slotlock.unlock();
		}
		objc_release(oldValue);
	}	 
	
	void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCppy) {
		bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);
		bool mutableCopy = (shouldCopy == MUTABLE_COPY);
		reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);
	}
	
* ##11.@synthesize和@dynamic分别有什么作用

以前如果没有手动加入settet和getter方法，需要使用@synthesize让编译器自动生成setter和getter方法。现在不需要了。
@dynamic告诉编译器开发者自己生成setter和getter方法不需要编译器来自动生成。

* ##14.@synthesize合成实例变量的规则是什么？假如property名为foo,存在一个名为_foo的实例变量，那么还会自动合成新变量吗?

总结下@synthesize合成实例变量的规则有以下几点：

1. 如果指定了成员变量的名称，会生成一个指定的名称的成员变量，
2. 如果这个成员变量已经存在了就不再生成了。
3. 如果是@synthesize foo;还会生成一个名为foo的成员变量，也就是说

>如果没有指定成员变量的名称会自动生成一个属性同名的的成员变量，

4. 如果是@synthesize foo = _foo;就不会生成成员变量了。

* ##15.在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？

在回答这个问题前，我们要搞清楚一个问题，什么情况不会autosynthesize(自动合成)?

1. 同事重写了setter和getter时
2. 重写了只读属性的getter时
3. 使用了@dynamic
4. 在@protocol中定义的所有属性
5. 在category中定义的所有属性
6. 重载的所有属性

当你在子类中重载了父类中的属性，你必须使用@synthesize来手动合成ivar。

除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理@property的所有内容时，你就会通过实现@property的所有"存取方法"或者使用@dynamic来达到这个目的，这是编译器就会认为你打算手动管理@property，于是编译器就禁用了autosynthesis(自动合成)。

因为有了autosynthesize(自动合成)，大部分开发者已经习惯不去手动定义ivar，而是依赖于autosynthesizs(自动合成)，但是一旦你需要使用ivar，而autosynthesis(自动合成)又失效了，如果不去手动定义ivar，那么你就得借助@synthesize来手动合成。

其实@synthesize还有一个使用场景，但是不建议大家去使用:

	@interface JERObject: NSObject
	@property (nonatomic, copy) NSString * title;
	@end
	
	@implementation UCNObject {
		// NSString  * _title;
	}
	
	//@synthesize title = _title;
	
	- (instancetype)init {
		self = [super init];
		if (self) {
			_title = @"";
		}
	}
	
	- (NSString *)title {
		return _title;
	}
	
	- (void)setTitle:(NSString *)title {
		_title = [title copy];
	}
	
	@end
	 
结果编译器报错：

![](https://Jeremy1221.github.io/img/retain_cycle/synthesize.png)

* 19.一个objc对象如何进行内存布局？(考虑有父类的情况)

>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中。
>每一个对象内部都有一个isa指针，指向他的类对象中，类对象中存放着本对象的:

1. 对象方法列表
2. 成员变量的列表
3. 属性列表

它内部也有一个isa指针指向元对象(meta class)，元对象内部存放的是类方法列表，类对象内部还有一个superclass的指针，指向他的父类对象。

每个Objective-C都有相同的结构，如下图所示

![](https://Jeremy1221.github.io/img/retain_cycle/class.png)

翻译过来就是

Objective-C对象的结构图 |
isa指针 |
根类的实例变量 |
倒数第二层父类的实例变量 |
... |
父类的实例变量 |
类的实例变量 |

| Name | Academy | score | 
| - | :-: | -: | 
| Harry Potter | Gryffindor| 90 | 
| Hermione Granger | Gryffindor | 100 | 
| Draco Malfoy | Slytherin | 90 |

* ##20.一个objc对象的isa指针指向什么？有什么作用？

指向他的类对象，从而可以找到对象上的方法.

* ##21.下面的代码输出什么？

		@implmentation Son : Father
		- (id)init {
			if (self = [super init]) {
				NSLog(@"%@", NSStringFromClass([self class]));
				NSLog(@"%@", NSStringFromClass([super class]))
			}
			return self;
		}
		@end

都输出Son

这个题目主要是考察关于Objective-C中对self和super的理解。
我们都知道：self是类的隐藏参数，指向当前调用方法的这个类的实例。那super呢？

很多人会想当然的认为"super和self类似，应该是指向父类的指针吧！"。这是很普遍的一个误区。其实super是一个magic keyword，它本质是一个编译器标识符，和self是指向的同一个消息接受者！他们两个的不同点在于：super会告诉编译器，调用class这个方法时，要去父类的方法而不是本类里的。

上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前Son *xxx这个对象。

当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用super时，则从父类的方法列表中开始找。然后调用父类的这个方法。

这也就是为什么说"不推荐在init方法中使用点语法"，如果想访问实例变量ivar应该使用下划线(_ivar),而非点语法(self.ivar)。

点语法(self.ivar)的坏处就是子类有可能覆写setter。假设Person有一个子类叫ChenPerson，该子类可能会覆写lastName属性所对应的设置方法:

@implementation

	- (instancetype)init {
		if (self = [super init]) {
			NSLog(@"🔴类名与方法名:%s(在第%d行)，描述:%@", __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class]));
			NSLog(@"🔴类名与方法名:%s(在第%d行)，描述:%@"， __PRETTY__FUNCTION__, __LINE__, NSStringFromClass[super class]);
		} 
		return self;
	}
	
	- (void)setLastname:(NSString *)lastname {
		//设置方法一：如果setter采用这种方式，就可能引起崩溃
		//if (![lastname isEqualToString:@"陈"]) {
		//		[NSException raise:NSInvalidArgumentException format:@"姓不是陈"];
		//}
		//		_lastname = lastname;
		
		_lastname = @"陈";
		NSLog(@"🔴类名与方法名:%s(在第%d行)，描述:%@", __PRETTY_FUNCTION__, __LINE__, @"会调用这个方法，想一下为什么?");
	}
	
在基类Person的默认初始化方法中，可能会将姓氏设为空字符串，此时使用点语法(self.lastname)也即setter设置方法，那么调用将会是子类的设置方法，如果在刚刚的setter代码中采用设置方法一，那么就会抛出异常，为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。

如果基类的代码是这样的:

@implementation Person

	- (instancetype)init {
		if (self = [super init]) {
			self.lastname = @"";
			
		}
		return self;
	}
	
	- (void)setLastname:(NSString *)lastname {
		NSLog(@"🔴类名与方法名:%s(在第%d行),描述:%@", __PRETTY_FUNCTION__, __LINE__, @"根本不会调用这个方法");
	}

那么打印结果将会是这样的:

	🔴类名与方法名： -[ChenPerson setLastname:](在第36行)， 描述：会调用这个方法，想一下为什么?
	🔴类名与方法名：-[ChenPerson init](在第19行)，描述：ChenPerson
	🔴类名与方法名：-[ChenPerson init](在第20行)，描述：ChenPerson

接下来让我们利用runtime的相关知识来验证一下super关键字的本质，使用clang重写命令：

	$clang -rewrite-objc test.m
	
将这道题目中给出代码被转化为:

	NSLog((NSString *)& __NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName("class"))));
	NSLog((NSString *)& __NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw__objc_super *, SEL))(void *)objc_msgSendSuper)((__rw__objc_super){(id)self, (id)class_getSuperClass(objc_getClass("Son"))}, sel_registername("class"))));
	
从上面的代码中，我们可以发现在调用[self class]时，会转化成objc_msgSend函数。看先函数定义:
	
	id objc_msgSend(id self, SEL op, ...)
	
我们把self做为第一个参数传递进去。

而在调用[super class]是，会转化成objc_msgSendSuper函数。看下函数定义:

	id objc_msgSendSuper(struct objc_super * super, SEL op ...)
	
第一个参数是objc_super这样一个结构体,其定义如下：

	struct objc_super {
		__unsafe__unretained id receiver;
		__unsafe__unretained Class super_class;
	};
	
结构体有两个成员，第一个成员是receiver，类似上面的objc_msgSend函数第一个参数self。第二个成员是记录当前类的父类是什么。

所以，当调用[self class]时，实际先调用的是objc_msgSend函数，第一个参数是Son当前的这个实例，然后再Son这个类里面去找- (Class)class这个方法，没有，去父类Father里找，也没有，最后再NSObject类中发现这个方法。而-(Class)class的实现就是返回self的类别，故上述输出结果为Son。

objc Runtime开源代码对-(Class)class方法的实现:

	- (Class)class {
		return object_getClass(self);
	}
	
而当调用[super class]时,会转换成objc_msgSendSuper函数。第一步先构造objc_super结构体，结构体第一个成员就是self。第二个成员是(id)class_getSuperClass("Son"),实际该函数输出结构为Father。

第二步是去Father这个类里去找 -(Class)class，没有，然后去NSObject类去找，找到了，最后内部是使用objc_msgSend(objc_super->receiver, @selector(class))去调用，此时已经和[self class]调用相同了，故上述输出结果仍然返回Son。

参考链接[刨根问底Objective－C Runtime（1）－ Self & Super](http://chun.tips/blog/2014/11/05/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(1)%5Bnil%5D-self-and-super/)

* ##22.runtime如何通过selector找到对应的IMP地址(分别考虑类方法和实例方法)

每一个类对象中都有一个方法列表，方法列表中记录着方法的名称，方法实现，以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现。

* ##23.使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放吗？

无论在ARC还是MRC下均不需要

[2011年版本的Apple API 官方文档 - Associative References](https://web.archive.org/web/20120818164935/http://developer.apple.com/library/ios/#/web/20120820002100/http://developer.apple.com/library/ios/documentation/cocoa/conceptual/objectivec/Chapters/ocAssociativeReferences.html)

	static char overviewKey;
	
	NSArray * array = [[NSArray alloc] initWithObjects:@"One", @"Two", @"Thress", nil];
	NSString * overview = [[NSString alloc] initWithFormat:@"%@", First three numbers];
	
	objc_setAssociatedObject (
		array,
		&overviewKey,
		overview,
		OBJC_ASSOCIATION_RETAIN
	);
	
	//point 1
	[overview release];
	//point 2
	[array release];
	
文档指出
>At point 1,the string overview is still valid because the OBJC_ASSOICATION_RETAIN policy specifies that the array retains the assoicated object.When the array is deallocated,however(at point 2),overview is released and so in this case also deallocated.

我们可以看到，在[array release]之后，overview就会被release释放掉了。

既然会被销毁，那么具体在什么时间点呢？
>根据[WWDC 2011, Session 322 (第36分22秒)](https://developer.apple.com/videos/wwdc/2011/#322-video)中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被NSObject-dealloc调用的object_dispose()方法中释放。

对象的内存销毁时间表，分为四个步骤:

#####1.调用-release引用计数变为0

* 对象正在被销毁，生命周期即将结束.
* 不能再有新的 __weak弱引用，否则将指向nil.
* 调用[self dealloc]

#####2. 子类调用 -dealloc
* 继承关系中最底层的子类在调用-dealloc
* 如果是MRC代码则会手动释放实例变量(ivars)
* 继承关系中每一次的父类都在调用 -dealloc

#####3. NSObject 调 -dealloc
* 只做一件事调用Objective-C runtime 中的 object_dispose()方法

#####4. 调用object_dispose()
* 为C++的实例变量调用destructors
* 为ARC状态下的实例变量(ivars)调用-release
* 解除所有使用runtime associate方法关联的对象
* 解除所有 __weak引用
* 调用free()

对象的内存销毁时间表:[参考链接](http://stackoverflow.com/a/10843510/3395008)

* ##24.objc中的类方法和实例方法有什么本质区别和联系？

类方法：
1. 类方法属于类对象的
2. 类方法只能通过类对象调用
3. 类方法中的self是类对象
4. 类方法可以调用其他的类方法
5. 类方法中不能访问成员变量
6. 类方法中不能直接调用对象方法

实例方法:
1. 实例方法是属于实例对象的
2. 实例方法只能通过实例对象调用
3. 实例方法中的self是实例对象
4. 实例方法中可以访问成员变量
5. 实例方法中直接调用实例方法
6. 实例方法也可以调用类方法(通过类名)

##new test 2 down
1. _objc_msgForward 函数是做什么的，直接调用它将会发生什么？
2. runtime如何实现weak变量的自动置nil？
3. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
4. runloop和线程有什么关系
5. runloop的mode作用是什么？
6. 以+scheduledTimerWithTimeInterval...的方式触犯的timer，在滑动页面上的列表时，timer会暂停回调，为什么？
7. 猜想runloop内部是如何实现的？
8. objc使用什么机制管理内存对象
9. ARC通过什么方式帮助开发者管理内存
10. 不手动指定autoreleasepool的前提下，一个autoreleasepool对象在什么时刻释放?(比如在一个vc的viewdidload中创建)
11. BAD_ACCESS在什么情况下出现
12. 苹果是如何实现autoreleasepool的
13. 使用block时什么情况会发生引用循环引用，如何解决？
14. 在block内如何修改block外部变量
15. 使用系统的某些block api(如UIView的block版本写动画时)，是否也考虑引用循环问题？
16. GCD的队列(dispatch_queue_t)分哪两种类型
17. 如何用GCD同步若干个异步调用？(如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图)
18. dispatch_barrier_async的作用是什么？
19. 苹果为什么要废弃dispatch_get_current_queue?
20. 以下代码运行结构如何？
21. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调?
22. 如何手动触发一个value的KVO
23. 若一个类有实例变量NSString * _foo, 调用setValue:forKey:时，可以以foo还是_foo作为key？
24. KVC的keyPath中的集合运算符如何使用?
25. KVC和KVO的keyPath一定是属性吗？
26. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？
27. apple用什么方式实现一个对象的KVO？
28. IBOutlet连出来的是图属性为什么可以被设置成weak？
29. IB中User Defined Runtime Attributes如何使用？
30. 如何调试BAD_ACCESS错误
31. lldb(gdb)常用的调试命令？

* ##1._objc_msgForward函数是做什么的，直接调用它将会发生什么？

>_objc_msgForward是IMP类型，用于消息转发的:当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。

我们可以这样创建一个_objc_msgForward对象：

	IMP msgForwardIMP = _objc_msgForward;
	
在上篇的《objc向一个对象发送消息[obj foo]和objc_msgSend函数之间有什么关系？》曾提到objc_msgSend在"消息传递"中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在Class中的缓存查找IMP(没缓存则初始化缓存)，如果没找到，则向父类的Class查找。如果一直找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后执行这个IMP

Objective-C运行时是开源的，所以我们可以看到它的实现。打开[Apple Open Source 里Mac代码里的obj包 ](http://www.opensource.apple.com/tarballs/objc4/)下载一个最新的版本，找到objc-runtime-new.mm,进入之后搜索_objc_msgForward。


对objc-runtime-new.mm文件里与_objc_msgForward有关的三个函数使用伪代码展示如下:

	id objc_msgSend(id self, SEL op, ...) {
		if (!self) return nil;
			IMP imp = class_getMethodImplementation(self->isa, SEL op);
			imp(self, op, ...);	//调用这个函数 伪代码
	}
	
	//查找IMP
	IMP class_getMethodImplementation(Class cls, SEL sel) {
		if (!cls || !sel) return nil;
		IMP imp = lookupImpOrNil(cls, sel);
		if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发
		return imp;
	}
	
	IMP lookupImpOrNil(Class cls, SEL sel) {
		if (!cls->initialize()) {
			_class_initialize(cls);
		}
		
		Class curClass = cls;
		IMP imp = nil;
		do {
			if (!curClass) break;
			if (!curClass->cache) fill_cache(cls, curClass);
			imp = cache_getImp(curClass, sel);
			if (imp)break;
		} while (curClass = curClass->superClass);
		return imp;
	}
	
虽然Apple没有公开_objc_msgForward的实现源码，但是我们还是能得出结论:
>\_objc_msgFoward是一个函数指针（和IMP的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。

为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下_objc_msgForward是如何进行转发的。

首先开启调试模式、打印出所有运行时发送的消息：可以在代码里执行下面的方法：

	(void)instrumentObjcMessageSends(YES);

或者断点暂停程序运行，并在gdb中输入下面的命令：

	call (void)instrumentObjcMessageSends(YES)
	
以第二种为例，操作如下所示：

![](https://Jeremy1221.github.io/img/retain_cycle/msgSend.png)

之后，运行时发送的所有消息都会打印到/tmp/msgSend-xxxx文件里了。

终端中输入命令前往:

	open /private/tmp
	
![](https://Jeremy1221.github.io/img/retain_cycle/tmpFile.png)

可能看到有多条，找到最新生成的，双击打开

在模拟器上执行以下语句(这一套调试方案仅用于模拟器，真机不可用，关于该调试方案的拓展链接:[ Can the messages sent to an object in Objective-C be monitored or printed out? ](http://stackoverflow.com/a/10750398/3395008)),向一个对象发送一条错误的消息:

	int main(int argc, char * argv[]) {
		@autoreleasepool {
			Test * test = [[Test alloc] init];
			[test performSelector:(@selector(doSomething))];
			return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
		}
	}
	
![](https://Jeremy1221.github.io/img/retain_cycle/msgForward.png)

你可以在/tmp/msgSend-xxxx（我这一次是/tmp/msgSend-89805）文件里，看到打印出来:

![](https://Jeremy1221.github.io/img/retain_cycle/forwardTmpFile.png)
	
结合[《NSObject官方文档》](https://developer.apple.com/library/prerelease/watchos/documentation/Cocoa/Reference/Foundation/Classes/NSObject_Class/#//apple_ref/doc/uid/20000050-SW11)，排除掉NSObject做的事，剩下的就是_objc_msgForward消息转发做的几件事:

1. 调用resolveInstanceMethod:方法(或resolveClassMethod:)。允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会影响这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。
2. 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。
3. 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。
4. 调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。
5. 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。

上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的

也就是说_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：

1. resolveInstanceMethod:方法 (或 resolveClassMethod:)。
2. forwardingTargetForSelector:方法
3. methodSignatureForSelector:方法
4. forwardInvocation:方法
5. doesNotRecognizeSelector: 方法
	
直接调用_objc_msgForward将会发生什么

直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序crash，但是如果用的好，能做很多非常酷的事。

正如前文所说:
>\_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。

如何调用_objc_msgForward？_objc_msgForward隶属于C语言，有三个参数:

| _objc_msgForward参数 | 类型
|所属对象 |id类型
|方法名 | SEL类型
|可变参数 |可变参数类型
	
首先了解下如何调用IMP类型的方法，IMP类型是如下格式：
为了直观，我们可以通过如下方式定义一个IMP类型：
	
	typedef void (*voidIMP)(id, SEL, ...)
	
一旦调用_objc_msgForward，将跳过查找IMP的过程，直接出发消息转发，

如果调用了_objc_msgForward,即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend:
>"我没有在这个对象里找到这个方法的实现"

有哪些场景需要直接调用_objc_msgForward?最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：[JSPatch（github链接)](https://github.com/bang590/JSPatch)就是直接调用了_objc_msgForward来实现其核心功能的:
>JSPatch以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。

作者的博文[《JSPatch实现原理详解》](http://blog.cnbang.net/tech/2808/)详细记录了实现原理，有兴趣可以看一下。

同时[_RAC_(ReactiveCocoa)](https://github.com/ReactiveCocoa/ReactiveCocoa)源码中也用到了该方法。


* ##2.能否向反编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？

1. 不能向编译后的类中添加实例变量
2. 能向运行时创建的类中添加实例变量

解释下：

* 因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime会调用class_setIvarLayout或class_setWeakIvarLayout来处理strong weak引用。所以不能向存在的类中添加实例变量；
* 运行时创建的类是可以添加实例变量，调用class_addIvar函数。但是得在调用objc_allocateClassPair之后，objc_registerClassPair之前，原因同上。

* ##3.runloop和线程有什么关系

总的来说，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生的，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分，Cocoa和CoreFoundation都提供了run loop对象方便配置和管理线程的run loop(以下都以Cocoa为例)。每个线程，包括程序的主线程(main thread)都与之相应的run loop对应。

runloop和线程的关系：

1.主线程的runloop默认是启动的。

iOS的应用程序里面，程序启动后会有一个如下的main()函数

	int main(int argc, char * argv[]) {
		@autoreleasepool {
			return UIAPPlicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
		}
	}
	
重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。

2.对其他线程来说，runloop默认是不启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程这是去执行一个长时间的已确定的任务则不需要。
3.在任何一个Cocoa程序的线程中，都可以通过一下代码来获取到当前线程的runloop。

	NSRunLoop * runloop = [NSRunLopp currentRunLoop];
	
参考链接[《Objective-C之runloop详解》](http://blog.csdn.net/wzzvictory/article/details/9237973)

* ##4. runloop的mode作用是什么？

model主要是用来指定事件在运行循环中的优先级的，分为：

1. NSDefaultRunLoopMode（KCFRunLoopDefaultMode）
2. UITrackingRunLoopMode
3. UIInitializationRunLoopMode:启动时
4. NSRunLoopCommonModes

苹果公开的Mode有两个： default和common

* ##5. 以+ scheduledTimerWithTimerINterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决
* ##6. 猜想runloop内部是如何实现的。 [深入理解runloop](http://blog.ibireme.com/2015/05/18/runloop/#base)
* ##7.objc使用什么机制管理对象内存

使用retainCount的机制来决定对象是否需要释放。每次runloop的时候，都是检查对象reatinCount，如果retainCount为0，就释放。

* ##8.ARC通过什么方式帮助开发者管理内存

ARC相对于MRC，不是在编译时添加reatin/release/autorelease/这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。

在编译期，ARC用的是更底层的C接口实现的reatin/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease。同时对同一上下文的同一对象的成对reatin/release操作进行优化(既忽略掉不必要的操作)；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略

* ##9. 不手动指定autorelease的前提下，一个autorelease对象在什么时刻释放？(比如在一个VC的viewDidload中创建)

分两种情况:手动干预释放时机、系统自动释放。

1. 手动干预释放时机--指定autorelease就是所谓的：当前作用域大括号结束时释放。
2. 系统自动去释放--不手动指定autorelease

autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的runloop迭代结束时释放。

释放的时机总结起来，可以用下图来表示:

![](https://Jeremy1221.github.io/img/retain_cycle/autoreleasepool.png)

从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件，触摸事件。

我们都知道：所有autorelease的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。

但是如果每次都放进应用程序的main.m中的autoreleasepool中，迟早有被撑满的一刻。这个过程必定有一个释放的动作。

在一次完整的运行循环之前，会被销毁。运行循环检测到事件并启动后，就是创建自动释放池。

子线程runloop默认是不工作的，无法主动创建，必须手动创建。

自定义的NSOperation和NSThread需要手动创建自动释放池。比如：自定义的NSOperation类中的main方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成了内存泄漏。

但对于blockOperation和invocationOperation这中默认的Operation，系统已经帮我们封装好了，不需要手动创建自动释放池。

@autoreleasepool当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release消息，释放自动释放池中的所有对象。

如果一个vc的viewDidload中创建一个Autorelease对象，那么该对象会在viewDidAppear方法执行前就被销毁了。

参考链接：[《黑幕背后的Autorelease》](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)

* ##10. BAD_ACCESS在什么情况下出现？

访问了野指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。死循环。

* ##11. 苹果如何实现autoreleasepool的？

autoreleasepool以一个队列数组的形式实现，主要通过下列三个函数完成。

1. objc_autoreleasepoolPush
2. objc_autoreleasepoolPop
3. objc_autorelease

看函数名就知道，对autorelease分别执行push和pop操作，销毁对象时执行了release操作。

举例说明：我们知道用类方法创建的对象都是Autorelease的，那么一旦Person出了作用域，挡在Person的dealloc方法中打上断点，我们就可以看到这样的调用堆栈信息:

![](https://Jeremy1221.github.io/img/retain_cycle/autorelease.png)

* ##12. 调用block时什么情况会发生引用循环，如何解决？
* ##13. 在block内如何修改block外部变量？

Block不允许修改外部变量的值。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。

我们可以打印下内存地址来进行验证：

	__block int a = 0;
	NSLog(@"定义前:%p", &a);					//栈区
	void (^foo)(void) = ^ {
		a = 1;
		NSLog(@"block 内部: %p", &a);		//堆区
	}；
	NSLog(@"定义后:%p", &a);					//堆区
	foo();
	
	定义前：0x16fda86f8
	定义后：0x155b22fc8
	block内部： 0x155b22fc8
	
block的内部变量会被copy到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。

那么如何证明“block内部”打印的是堆地址？

把三个16进制的内存地址转成10进制就是：

1.定义前：6171559672

2.block内部：5732708296

3.定以后：5732708296

中间相差438851376个字节，也就是418.5M的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。

这也证实了：a在定义前是栈区，但只要进入了block区域，就变成了堆区。这才是__block关键字的真正作用。

__block关键字修饰后，int类型也从4字节变成了32字节，这是Foundation框架malloc出来的。这也同样能证实上面的结论。（PS：居然比NSObject alloc出来的16字节要多一倍）。

理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然如何解释下面这一现象:

一下代码编译可通过，并且在block中成功将a的值从Tom修改为Jerry。

	NSMutableString * a = [NSMutableString stringWithString:@"Tom"];
	NSLog(@"\n 定义前------------------\n\a指向前的堆中地址：%P；a在栈中指针地址：%p", a, &a);
	
	void(^foo)(void)= ^{
		a.string = @"Jerry";
		NSLog(@"\n block内部：---------------------\n\a指向的堆中的地址：%p；a在栈中的指针地址：%p", a, &a);
		a = [NSMutableString stringWithString:@"William"];
	}
	foo();
	NSLog(@"\n 定义后--------------------\n\a指向的堆中的地址：%p；a在栈中的指针地址：%p", a, &a);

![](https://Jeremy1221.github.io/img/retain_cycle/block_result.png)

这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变指针所指向堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。

但如果我们尝试向上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。

* ##14. 使用系统的某些block API(如UIView的block版本写动画时)，是否也考虑循环引用问题？

系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api需要考虑：

如果你使用一些参数中可能含有ivar的系统api，如GCD、NSNotificationCenter就要小心一点：比如GCD内部如果引用了self，而且GCD的其他参数是ivar，则要考虑到循环引用：

	__weak __typeof(__self) weakSelf = self;
	dispatch_group_async(_operationsGroup, _operationsQueue, ^{
		__typeof__(self) strongSelf = weakSelf;
		[strongSelf doSomething];
		[strongSelf doSomethingElse];
	});
	
类似的：

	__weak __typeof__(self) weakSelf = self;
	
	_obsever = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey" object:nil queue:nil usingBlock:^(NSNotification * note){
		__typeof__(self) strongSelf = wealSelf;
		[strongSelf dismissModalViewContronllerAnimated:YES];
	}];
	
self->_observer->block->self显然这也是一个循环引用。

* ##15. GCD的队列分哪两种类型？

1.串行队列Serial Dispatch Queue
2.并行队列Concurrent Dispatch Queue

* ##16. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）

使用Dispatch Group追加block到Global Group Queue，这些block如果全部执行完毕，就会执行Main Dispatch Queue中的

	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	dispatch_group_t group = dispatch_group_create();
	dispatch_group_async(group, queue^{/*加载图片1*/});
	dispatch_group_async(group, queue^{/*加载图片2*/});
	dispatch_group_async(group, queue^{/*加载图片3*/});
	dispatch_group_notify(group, dispatch_get_main_queue(), ^{/*合并图片*/});

* ##17. dispatch_barrier_asyncde的作用是什么？

在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用barrier来等待之前任务完成，避免数据竞争等问题。dispatch_barrier_async函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行dispatch_barrier_async函数追加的处理，等dispatch_barrier_async追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。

（注意：使用dispatch_barrier_async，该函数只能搭配自定义并行队列dispatch_queue_t使用。不能使用dispatch_get_global_queue,否则dispatch_barrier_async的作用会和dispatch_async的作用一模一样。）

* ##18. 苹果为什么要废弃dispatch_get_current_queue？

dispatch_get_current_queue容易造成死锁

* ##19. 以下代码运行结果如何

		- (void)viewDidload {
			[super viewDidload];
			NSLog(@"1");
			dispatch_sync(dispatch_get_main_queue(), ^{
				NSLog(@"2");
			});
			NSLog(@"3");
		}

只输出1，发生主线程锁死。

* ##20. addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？

		//添加键值观察
		/*
		1 观察者，负责处理监听事件的对象
		2 观察的属性
		3 观察的选项
		4 上下文
		*/
		[self.person addObserver:self forKeyPath:@"" options:NSKeyValueObservingOptioneNew | NSKeyValueObservingOptionOld context:@""];
		
observer中需要实现以下方法：

	// 所有的kvo监听到事件，都会调用此方法
	/*
	1 观察的属性
	2 观察的对象
	3 change属性变化字典(新/旧)
	4 上下文，与监听的时候传递的一致
	*/
	- (void)observerValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary*)change context:(void*)context;
		
* ##21. 如何手动触发一个value的KVO

所谓的“手动触发”是区别于“自动触发”：

自动触发是指类似这种场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。

想知道如何手动触发，就必须知道KVO的触发原理：

键值观察通知依赖于NSObject的两个方法willChangValueForKey:和didChangeValueForKey:。在一个被观察者属性发生改变之前，willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生后，observerValueForKey:forKey:ofObject:change:content:会被调用，继而didChangeValueForKey:也会被调用。如果可以手动实现这些调用，就可以实现"手动触发"了。

那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。

具体做法如下：

如果这个value是表示时间的self.now,那么代码如下：最后两行缺一不可。

相关代码已放在仓库里。

	//@property (nonatomic, strong)NSDate * now;
	- (void)viewDidLoad {
		[super viewDidLoad];
		_now = [NSDate date];
		[self addObserver:self forKeyPath:@"now" options:NSKeyValueObservingOptionNew contenxt:nil];
		NSLog(@"1");
		[self willChangeValueForKey:@"now"];
		NSLog(@"2");
		[self didChangeValueForkey:@"now"];
		NSLog(@"3");
	}

但是我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：
>比如调用setNow:时，系统还会以某种方式在中间插入willChangeValueForKey:、didChangeValueForKey:和observeValueForKeyPath:ofObject:change:context:的调用。

大家可能以为这是因为setNow:是合成方法，有时候我们也能看到有人这么写代码：

	- (void)setNow:(NSDate *)now {
		[self willChangeValueForKey:@"now"];
		_now = now;
		[self didChangeValueForKey:@"now"];
	}
	
会调两次。[参考链接Manual Change Notification---Apple官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html#//apple_ref/doc/uid/20002178-SW3)

* ##22. 若一个类有实例变量 NSString * _foo,调用setValue:forKey:时，可以以foo还是_foo作为key？

都可以。

* ##23. KVC的keyPath中的集合运算符如何使用？

1.必须用在集合对象上或普通对象的集合属性上
2.简单集合运算符有@avg,@count,@max,@min,@sum,
3.格式@"@sum.age"或@"集合属性.@max.age"

	@interface Person: NSObject
	@property (nonatomic, assign) NSinteger age;
	@end
	
	- (void)viewDidLoad {
		[super viewDidLoad];
	
		Person *p2 = [[Person alloc] initWithName:@"xiaoming" andAge:15];
    	Person *p3 = [[Person alloc] initWithName:@"xiaohong" andAge:20];
		Person *p4 = [[Person alloc] initWithName:@"xiaoli" andAge:30];
    	Person *p5 = [[Person alloc] initWithName:@"xiaoli" andAge:55];
	}
	
	NSArray *perArray = @[p1, p2, p3, p4, p5];
     
     // 简单集合运算符
     NSInteger avg = [[perArray valueForKeyPath:@"@avg.age"] integerValue];
     NSInteger sum = [[perArray valueForKeyPath:@"@sum.age"] integerValue];
     NSInteger max = [[perArray valueForKeyPath:@"@max.age"] integerValue];
     NSInteger min = [[perArray valueForKeyPath:@"@min.age"] integerValue];

* ##24. KVC和kVO的keyPath一定是属性吗？

KVC支持实例变量，KVO只能手动支持[手动设定实例变量的KVO实现监听](https://yq.aliyun.com/articles/30483)

* ##25. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现

1.[如何自己手动实现KVO](http://tech.glowing.com/cn/implement-kvo/)

2.[KVO for manually implemented properties](http://stackoverflow.com/a/10042641/3395008)

* ##26. apple用什么方式实现对一个对象的KVO？

Apple的文档对KVO实现的描述：
>Automatic Key-value observing is implemented using a technique called isa-swizzling... When an observer is registerd for an attribute of an object the isa pointer of the observed object is modified, point to an intermediate class rather than at the true class...

从Apple的文档可以看出：Apple并不希望过多暴露KVO的实现细节。不过，要是借助runtime提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：
>当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的setter方法。重写的setter方法会负责在调用原setter方法之前和之后，通知所有观察对象:值的更改。最后通过isa混写(isa-swizzling)把这个对象的isa指针(isa指针告诉Runtime系统这个对象的类是什么)指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示：

* ##27. IBOutlet连出来的视图属性为什么可以被设置成weak

参考链接:[Should IBOutlets be strong or weak under ARC](http://stackoverflow.com/questions/7678469/should-iboutlets-be-strong-or-weak-under-arc)

文章告诉我们：
>因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。

不过这个回答漏了个重要知识，使用storyboard(xib不行)创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有toplevel的对象，所以这是即便outlet声明成weak也没关系

* ##28. IB中User Defined Runtime Attributes如何使用？

它能够通过KVC的方式配置一些你再Interface builder中不能配置的属性。当你希望在IB中作尽可能多的事情，这个特性能够帮助你编写更加轻量的viewcontroller。

* ##29. 如何调试BAD_ACCESS错误

1.重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object

2.通过zombie

3.设置全局断点快速定位问题代码所在行

4.Xcode7已经集成了BAD_ACCESS捕获功能：Address Sanitizer。用法如下：在配置中勾选✅Enable Address Sanitizer

* ##30. llgd(gdb)常用的调试命令？

1.breakpoint设置断点定位到某一个函数

2.n断点指针下一步

3.po打印对象

更llgd(gdb)调试命令可查看

1.[The LLDB Debugger](http://lldb.llvm.org/lldb-gdb.html)

2.苹果官方文档[iOS Debugging Magic](https://developer.apple.com/library/ios/technotes/tn2239/_index.html)

#new interview test 3


