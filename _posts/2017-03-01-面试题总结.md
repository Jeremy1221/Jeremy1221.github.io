===
最高阶标题
===

---
title: The interview questions summary
description: This is an introduction to summary of interview questions
#header: 面试题总结
---

工作两年多，依然对面试中的技术感到手足无措，从大学后一直玩物丧志，所以接下来从面试题中学习来弥补之前的堕落。这篇文章将要写很长。

1. MVC设计模式：

M：model数据源： 负责存储，定义，操作数据
V：view展示给用户看，负责与用户的交互
C：controller可以和m和v直接通信，v要通过代理来和c通信，m通过kvo或nsnotification和c通信，m和v不能直接通信。c负责将m的数据交给v使用。

2. 循环引用。

![retain_cycle_1](https://Jeremy1221.github.io/img/retain_cycle/retain_cycle_1.png)

我的理解：对象A和B互相持有，当我们想要销毁A时，因为A持有B，然后我们回去尝试销毁B，此时我们发现B又持有A，然后我们有尝试去销毁B。如此循环下来我们就没法销毁任何一个。

![retain_cycle_2](https://Jeremy1221.github.io/img/retain_cycle/retain_cycle_2.png)

如果多个对象之间存在这个问题，对象越多，环越大，就越难发现这个问题。


3. 线程与进程

一个程序只有一个进程，一个进程可以有多个线程。
进程资源分配的最小独立单元
一个线程死了，这个进程就死了，但是进程间没有这个问题，因为进程有自己的独立地址空间，所以进程比较安全，但是进程间切换消耗资源大，效率差。
要求同时进行并且共享资源的时候只能用线程，不能用进程。

4. LayoutSubViews在什么时候被调用？

当View本身的frame改变时，会调用这个方法。

5. loadView

controller的view为nil时会调用，viewDidLoad在view从nib文件初始化时调用

6. __block和__weak

7. 堆和栈

栈区是由系统自行管理的，堆是程序员来管理的
栈是连续的，堆是不连续的所以会产生碎片
堆是动态分配，栈是动态和静态分配的
栈的分配效率比堆高

8. xml解析

dom和sax dom处理规模较大的文档是很耗内存占用资源比较多

9. _objc_msgForward函数是做什么的，直接调用它将会发生什么？
10. http://www.cocoachina.com/ios/20150825/13195.html
11.  能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
12.  applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。
13.  如何终止正在运行的工作线程？
14.  instrument
15.  聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。
16.  谈下Objective C都有哪些锁机制，你一般用哪个？
17.  介绍下iOS设备获取唯一设备号的历史变迁。
18.  iOS下如何实现指定线程数目的线程池？
19.  数据库建表的时候索引有什么用？
20.  如何用HTTP实现长连接？
21.  解释下tcp的慢启动特性。
22.  如何自己高效实现NSUserDefault?
23.  NSString如何计算字符的个数？
24.  PKI体系当中加密和签名有什么区别？

看到这个题目是一个群里的朋友发的，感谢那个兄弟，看到MrPeak大大出的题目啊 好开心，试着答，各位大大请轻喷，刚好不怎么忙，带着耳机听歌，答了一个小时，真舒服啊，看到这些题目好多都不怎么知道，恶补，学习。

1.NSString如何计算字符的个数？

应该是用countElements的函数来统计字符串所包含的字符个数，把参数为要统计的字符串就好了。

但是需要注意以下的几个点：

1.因为不同的Unicode字符，同样的字符不同的编码都可能导致占用不同的内存。所以按正常来说，字符串中的每个字符会占用不同的内存。因此，只能通过遍历字符串中的每个字符来计算字符串的长度。但是当在处理一个特别长的字符串的话，可以通过遍历遍历整个字符串，这样既可以算出字符串的长度了。

2.同一个字符串，countElements计算出来的字符个数与NSString的length计算出来的长度也不一定总是一样的的。因为NSString的长度是基UTF-16编码的编码来计算的，而不是Unicode编码的个数。但是，好像在Swift中可以使用字符串的utf16count属性来来获得原来NSString的length值，忘记了，很久没用Swift了。

2.PKI体系当中加密和签名有什么区别？

这个问题我来答的话，应该先说说PKI是一种安全技术, 数字签名和加密基本原理是什么，在说区别，话说基本原理我也不记得了，就大概记得一个HUSH函数什么的了，他们的过程都是使用公开密钥体系，但实现的过程是不同的，相反，使用的密钥对也不同。

1.数字签名是发送方的密钥对，发送方用自己的私有密钥进行加密，接收方用发送方的公开密钥进行解密，大致就是这样吧，它一个一对多的关系，任何拥有发送方公开密钥的人都可以验证数字签名的正确性，还有只采用了非对称密钥加密算法,能保证发送信息的完整性、身份认证和不可否认性。

2.数字加密是接收方的密钥对，这是多对一的关系，任何知道接收方公开密钥的人都可以向接收方发送加密信息，只有唯一拥有接收方私有密钥的人才能对信息解密,用的对称密钥加密算法和非对称密钥加密算法相结合的方法，它能保证发送信息保密性。

3.如何自己高效实现NSUserDefault?

这个，真心不知道，peak大大。只知道NSUserDefaults是定时把缓存中的数据写入磁盘的，而不是即时写入，为了防止在写完NSUserDefaults后程序退出导致的数据丢失，可以在写入数据后使用synchronize强制立即将数据写入磁盘，现在要高效的实现NSUserDefaults，个人见解就是不频繁的使用synchornize，自定义一个类，再存取时通过NSData做载体。

4.解释下tcp的慢启动特性。

现在公司应该都是在避免慢启动，做性能优化吧，优化应该可以尽量把大量小文件放在一个TCP连接中排队传输吧，没试验过，自己YY的。

这问的是Tcp慢启动的特点，难道就是它在新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量，但是这样的话 性能呢，请科普下，谢谢。

5.如何用HTTP实现长连接？

首先HTTP是无状态的，要维持一个长连接可以用心跳包啊，公司项目第一个版本就是这样用的，然后各种原因，各种呵呵呵，丢包，沾包，应该可以对http连接进行轮询，但是http定时轮询会存在延迟 用户体验就不好了 或者用socket流方法，监听服务器消息

6.HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？

一个吗？不是很清楚啊。

7.数据库建表的时候索引有什么用？

创建索引可以大大提高系统的性能，加快数据的检索速度，加速表和表之间的连接，保证数据库表中每一行数据的唯一性，但是有些列不应该创建索引，这又要考虑到性能了，所以具体情况具体分析了。

8.Full Text Search为什么快？

这我不是后台不是很了解，问题偏后台系统多一点点了，但是自己会写一点点PHP，好像是用空间来换时间,通过分词器，降索引的表分割啥的，不是很清楚原理啊，看来要系统学下后台语言。

9.iOS下如何实现指定线程数目的线程池？

这个问题问的太深了吧，一般开发根本用不到，还好最近在看线程安全方面的书籍，要不然问到真的会懵逼。

1.循环通过pthread_create创建线程，创建s_tfthread对象做为线程句，加入线程数组,s_tftask_content->methord初始化为空函数

2.创建任务执行函数，执行完通过task初始化函数后，在执行函数中通过pthread_cond_wait信号将当前创建的线程挂起

3.创建完之后，程序中将会有n个挂起状态的线程，当需要执行新的task的时候查找，我们就可以根据不同的task标志在k_threads中查询出空闲线程，并创建新的s_tftask_content加入s_tfthread的任务列表，通过pthread_cond_signal重新唤醒该线程继续执行任务

10.介绍下iOS设备获取唯一设备号的历史变迁。

这个没做过几年开发的真心不知道，iOS中获取设备唯一标示符的方法一直随版本的更新而变化。iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，但是好像是iOS 4还是iOS5就被苹果废弃掉了，然后iOS6是用WiFi的mac地址来获取的，iOS7后大家都知道了，主要是由于苹果又坑爹了，封杀mac地址，但是推荐大家用KeyChain来保存获取到的UDID，因为APP删了再装回来，也可以从KeyChain中读取回来，哈哈，公司的项目都是把UDID存在KeyChain。

11.函数式编程当中的 first-class function是什么意思呢？

这个问题好像以前就在知乎看过，就是类型，定义了一个可以操作的取值的集合，就像C语言的int类型一样，可进行加减乘除等操作，但是它的设计又有一个模块复用和访存控制,这样设计的原因应该是让我们更好用吧，没有深究过这个。

12.如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？

做到这里在电脑码字快三十分钟了啊，peak大大，你问的问题都好难回答啊，要分各种情况。这题也是首先要考虑 hook是否有公开头文件的类，有的话写一个Utility函数，再使用category，没有的话就建一个类作为新函数载体，然后先为被hook的类增加函数，再替换，没错就是这个样子。后面如何h如何hook某个instance的方法，应该可以定义一个函数指针变量，hook时将要调用的地址赋给这个变量，调用时把这个变量当作函数来用就行了。

13.谈下Objective C都有哪些锁机制，你一般用哪个？

synchronized、NSLOCK、GCD、递归锁、分布锁、同步锁（这个是C语言的），一般用GCD，这里就不说了，真心不想码字了，peak大大可能会问，为什么，又要把各种锁机制对比，这我会疯，我脑袋要死机了，重启中…

14.聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。

http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE，刚好公司上个项目都用了这四种方式的请求，怎么都是踩过得坑。

form-urlencoded是默认的mime内容编码类型，是通用的，但是它在传输比较大的二进制或者文本数据时效率极低。

multipart/form-data是当上传文件或者二进制数据和非ASCII数据使用。

15.让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？

这个问题没有考虑过，都是自己写单元测试什么的来测试，都是些基础的测试，一般都是用Instrument来测试一些东西的。自己设计的话，主要还是要考虑一个VC的生命周期。

16.通过[UIImage imageNamed:]生成的对象什么时候被释放？

应该是到@autoreleasepool 结束的时候才释放的，但是我都是用这imageWithContentsOfFile方法加载图片的

17.applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。

推送、做支付的时候，跳到人家运用，后台杀进程的时候、做IM的时候、第三方授权分享登录回调情况下等等

18.如何终止正在运行的工作线程？

在线程中调用exit、pthread_exit、pthread_kill、pthread_cance都行吧

19.穷举iOS下所有的本地持久化方案。

沙盒

plist文件（属性列表）

preference（偏好设置）

NSKeyedArchiver（归档）

SQLite 3

CoreData

还有请补充...

20.如果公司强制996，你有什么心里话要对老板说吗？

没什么话，习惯了，主要想要对产品经理说你的需求能不能想好在做，不要瞎搞，谢谢

swift知识点总结：

Swift 增加了可选（Optional）类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 nil 指针更加安全也更具表现力。

Swift 是一门类型安全的语言

你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：

	let π = 3.14159
	let 你好 = "你好世界"
	let 🐶🐮 = "dogcow"

常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。

注意：
如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。

有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：

	let cat = "🐱"; print(cat)
	// 输出 "🐱"

当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。

类型别名
类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。

typealias AudioSample = UInt16

>__注意：
如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。__

你可以使用全局 assert(_:_:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：

	let age = -3
	assert(age >= 0, "A person's age cannot be less than zero")
	// 因为 age < 0，所以断言会触发

>**注意：
Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。**

例如，如果你用四个字符的单词cafe初始化一个新的字符串，然后添加一个COMBINING ACTUE ACCENT(U+0301)作为字符串的结尾。最终这个字符串的字符数量仍然是4，因为第四个字符是é，而不是e：

	var word = "cafe"
	print("the number of characters in \(word) is \(word.characters.count)")
	// 打印输出 "the number of characters in cafe is 4"
	
	word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301
	
	print("the number of characters in \(word) is \(word.characters.count)")
	// 打印输出 "the number of characters in café is 4"

>注意：

>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意characters属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。

>另外需要注意的是通过characters属性返回的字符数量并不总是与包含相同字符的NSString的length属性相同。NSString的length属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。

Swift 语言提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。

![]()

隐式解析可选类型

如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。

值绑定（Value Bindings）

case 分支允许将匹配的值绑定到一个临时的常量或变量，并且在case分支体内使用 —— 这种行为被称为值绑定（value binding），因为匹配的值在case分支体内，与临时的常量或变量绑定。

下面的例子展示了如何在一个(Int, Int)类型的元组中使用值绑定来分类下图中的点(x, y)：

let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// 输出 "on the x-axis with an x value of 2"
image

在上面的例子中，switch语句会判断某个点是否在红色的x轴上，是否在橘黄色的y轴上，或者不在坐标轴上。

这三个 case 都声明了常量x和y的占位符，用于临时获取元组anotherPoint的一个或两个值。第一个 case ——case (let x, 0)将匹配一个纵坐标为0的点，并把这个点的横坐标赋给临时的常量x。类似的，第二个 case ——case (0, let y)将匹配一个横坐标为0的点，并把这个点的纵坐标赋给临时的常量y。

一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里使用。在这个例子中，它们用于打印给定点的类型。

请注意，这个switch语句不包含默认分支。这是因为最后一个 case ——case let(x, y)声明了一个可以匹配余下所有值的元组。这使得switch语句已经完备了，因此不需要再书写默认分支。


Where

case 分支的模式可以使用where语句来判断额外的条件。

下面的例子把下图中的点(x, y)进行了分类：

let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// 输出 "(1, -1) is on the line x == -y"
image

在上面的例子中，switch语句会判断某个点是否在绿色的对角线x == y上，是否在紫色的对角线x == -y上，或者不在对角线上。

这三个 case 都声明了常量x和y的占位符，用于临时获取元组yetAnotherPoint的两个值。这两个常量被用作where语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当where语句的条件为true时，匹配到的 case 分支才会被执行。

就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，switch语句就已经完备了，因此不需要再书写默认分支。

贯穿

Swift 中的switch不会从上一个 case 分支落入到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个switch代码块完成了它的执行。相比之下，C 语言要求你显式地插入break语句到每个 case 分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的switch 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。

如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用fallthrough关键字。下面的例子使用fallthrough来创建一个数字的描述语句。

let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
print(description)
// 输出 "The number 5 is a prime number, and also an integer."

>注意： fallthrough关键字不会检查它下一个将会落入执行的 case 中的匹配条件。fallthrough简单地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的switch语句特性是一样的。

带标签的语句

	let finalSquare = 25
	var board = [Int](repeating: 0, count: finalSquare + 1)
	board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
	board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
	var square = 0
	var diceRoll = 0
	
	gameLoop: while square != finalSquare {
	    diceRoll += 1
	    if diceRoll == 7 { diceRoll = 1 }
	    switch square + diceRoll {
	    case finalSquare:
	        // 骰子数刚好使玩家移动到最终的方格里，游戏结束。
	        break gameLoop
	    case let newSquare where newSquare > finalSquare:
	        // 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子
	        continue gameLoop
	    default:
	        // 合法移动，做正常的处理
	        square += diceRoll
	        square += board[square]
	    }
	}
	print("Game over!")

>注意：
如果上述的break语句没有使用gameLoop标签，那么它将会中断switch语句而不是while循环。使用gameLoop标签清晰的表明了break想要中断的是哪个代码块。 同时请注意，当调用continue gameLoop去跳转到下一次循环迭代时，这里使用gameLoop标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以continue语句会影响到哪个循环体是没有歧义的。然而，continue语句使用gameLoop标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的break gameLoop，能够使游戏的逻辑更加清晰和易于理解。

检测 API 可用性
Swift内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的API。

我们在if或guard语句中使用可用性条件（availability condition)去有条件的执行一段代码，来在运行时判断调用的API是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。

	if #available(iOS 10, macOS 10.12, *) {
	    // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API
	} else {
	    // 使用先前版本的 iOS 和 macOS 的 API
	}
以上可用性条件指定，在iOS中，if语句的代码块仅仅在 iOS 10 及更高的系统下运行；在 macOS中，仅在 macOS 10.12 及更高才会运行。最后一个参数，*，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。

在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是iOS，macOS，watchOS和tvOS——请访问声明属性来获取完整列表。除了指定像 iOS 8的主板本号，我们可以指定像iOS 8.3 以及 macOS 10.10.3的子版本号。

	if #available(platform name version, ..., *) {
	    APIs 可用，语句将执行
	} else {
	    APIs 不可用，语句将不执行
	}

闭包表达式语法

闭包表达式语法有如下的一般形式：

{ (parameters) -> returnType in
    statements
}

逃逸闭包
这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。

递归枚举
递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。

例如，下面的例子中，枚举类型存储了简单的算术表达式：

enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：

indirect enum ArithmeticExpression {
    case number(Int)
    case addition(ArithmeticExpression, ArithmeticExpression)
    case multiplication(ArithmeticExpression, ArithmeticExpression)
}
上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) * 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) * 2

let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))
要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：

func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}

print(evaluate(product))
// 打印 "18"
该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。

类和结构体对比
Swift 中类和结构体有很多共同点。共同处在于：

定义属性用于存储值
定义方法用于提供功能
定义下标操作使得可以通过下标语法来访问实例所包含的值
定义构造器用于生成初始化值
通过扩展以增加默认实现的功能
实现协议以提供某种标准功能
更多信息请参见属性，方法，下标，构造过程，扩展，和协议。

与结构体相比，类还有如下的附加功能：

继承允许一个类继承另一个类的特征
类型转换允许在运行时检查和解释一个类实例的类型
析构器允许一个类实例释放任何其所被分配的资源
引用计数允许对一个类的多次引用

按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：

该数据结构的主要目的是用来封装少量相关简单数据值。
有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
该数据结构不需要去继承另一个既有类型的属性或者行为。
举例来说，以下情境中适合使用结构体：

几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
三维坐标系内一点，封装x，y和z属性，三者均为Double类型。

延迟存储属性

延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性。

注意
必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。

下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：

class DataImporter {
    /*
    DataImporter 是一个负责将外部文件中的数据导入的类。
    这个类的初始化会消耗不少时间。
    */
    var fileName = "data.txt"
    // 这里会提供数据导入功能
}

class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // 这里会提供数据管理功能
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// DataImporter 实例的 importer 属性还没有被创建
DataManager 类包含一个名为 data 的存储属性，初始值是一个空的字符串（String）数组。这里没有给出全部代码，只需知道 DataManager 类的目的是管理和提供对这个字符串数组的访问即可。

DataManager 的一个功能是从文件导入数据。该功能由 DataImporter 类提供，DataImporter 完成初始化需要消耗不少时间：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。

DataManager 管理数据时也可能不从文件中导入数据。所以当 DataManager 的实例被创建时，没必要创建一个 DataImporter 的实例，更明智的做法是第一次用到 DataImporter 的时候才去创建它。

由于使用了 lazy ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：

print(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 "data.txt”
注意
如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。

类型属性语法

在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。

使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：

struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 6
    }
}
class SomeClass {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 27
    }
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}


在可变方法中给 self 赋值

可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写：

struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}
只能用于结构体中(或者说值类型中，我猜的，而不能用于类中引用类型)

因为允许在调用advance(to:)时候忽略返回值，不会产生编译警告，所以函数被标注为@ discardableResult属性

下标

struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -> Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print("six times three is \(threeTimesTable[6])")
// 打印 "six times three is 18"

防止重写
你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。

如果你重写了带有final标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final 的。

你可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。

不带外部名的构造器参数

init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0

struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
两种构造器都能用于创建一个新的Color实例，你需要为构造器每个外部参数传值：

let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：

let veryGreen = Color(0.0, 1.0, 0.0)
// 报编译时错误，需要外部名称

结构体的逐一成员构造器
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)


构造器的继承和重写

跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。

注意
父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节构造器的自动继承。


解决实例之间的循环强引用
Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。

弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。

当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。


弱引用

弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上weak关键字表明这是一个弱引用。

因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。

你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。

注意
当 ARC 设置弱引用为nil时，属性观察不会被触发。
下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：

class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：

var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")

john!.apartment = unit4A
unit4A!.tenant = john

无主引用

和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。

由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。

>注意:
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。
还需要注意的是如果你试图访问实例已经被销毁的无主引用，程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。 

由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：

    class Customer {
        let name: String
        var card: CreditCard?
        init(name: String) {
            self.name = name
        }
        deinit { println("\(name) is being deinitialized") }
    }

    class CreditCard {
        let number: Int
        unowned let customer: Customer
        init(number: Int, customer: Customer) {
            self.number = number
            self.customer = customer
        }
        deinit { println("Card #\(number) is being deinitialized") }
    }

下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil。

    var john: Customer?

现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性。

    john = Customer(name: "John Appleseed")
    john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。

Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。

定义捕获列表

捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。

如果闭包有参数列表和返回类型，把捕获列表放在它们前面：

lazy var someClosure: (Int, String) -> String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
    // 这里是闭包的函数体
}

如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：

lazy var someClosure: Void -> String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}


弱引用和无主引用

在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。

相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。

    注意
    如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。
