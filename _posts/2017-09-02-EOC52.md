---
title: Effective Objective-C 2.0
header: Effective Objective-C 2.0
desciption: 编写高质量iOS与OS X代码的52个有效方法
---

##第一章 熟悉Objective-C

###1. 了解Objective-C的起源

使用"消息结构"而非"函数调用"，由smalltalk演化而来，后者是消息型语言的鼻祖。

使用消息型语言，在程序运行时具体调用哪个函数是动态改变的，需要从虚方法表中查找，而且不关心调用的对象是谁，函数调用具体调用的函数是由编译器决定的。

运行有个运行期组件，这里面有方法运行时所需的所有方法，在运行时只需优化运行期组件便可提升程序性能，而编译器决定的需要重新编译代码。

创建的OC对象是保存在堆内存中的，指向对象的指针是保存在栈内存中的，栈由系统管理，堆需要手动管理，OC提供了"应用计数"的架构来管理。
	
	//这时创建了一个OC对象，保存在堆内存中，
	[[NSString alloc] init];

	//str1是一个指向NSString实例的指针，保存在栈内存中。
	NSString * str1 = [[NSString alloc] init];

	//str2是也一个指向NSString实例的指针，保存在栈内存中。
	NSString * str2 = str1;


一些基础数据类型，像int float struct是保存在栈中的。

###2. 在类的头文件中尽量少引入其他头文件

有时候在头文件中要用的某个类，但是并不关心这个类的具体细节，可以使用向前声明 @SomeClass,如果引入了头文件，将会增加编译时间。
在头文件中互相引用的话，将会导致循环引用无法编译，虽然#import相对于#include会避免死循环，但是也会导致某个类无法编译。
最好把协议单独放在一个头文件中，如果将协议放在了某个大的文件中，在引入此协议时，也会引入这个文件中的全部内容，会产生相互因爱问题，还会增加编译时间。(委托协议除外)。
若要实现属性，实例变量或者遵循协议而引入头文件，尽量在分类中实现，这样做不仅可以减少编译时间，还能降低彼此依赖度。

###3. 多用字面量语法
字面量语法可以简化代码，增加可读性。字面量语法其实是由“语法糖”来实现的，语法糖的实质就是调用初始化方法。
字面量语法创建字典数组时如果插入了nil将会抛出异常，导致程序崩溃。而是用初始化方法时不遇到nil时会停止插入动作，即可返回对象。
	
	id object1 = /*...*/;
	id object2 = nil;
	id object3 = /*...*/;
	  
	NSArray * array1 = [NSArray arrayWithobjects:object1, object2, object3, nil];
	NSArray * array2 = @[object1, object2, object3];
字面量语法创建的对象都是不可变的，如果需要可变的需要复制一份。
	NSMutableArray * array = @[[1, 2, 3] mutableCopy];

###4. 多用类型常量，少用#define预处理指令
	
	//命名规则,在实现文件里加上k前缀,在头文件中以类名为前缀
	static const float time = 3
	#define time 3
#defien在使用时，是将time直接替换，使用类型常量可以知道将要使用的是什么类型的 int？ float？ NSString？
一般不要在同文件中声明常量，如果头文件被别的文件引用，也会一同将常量引入，而且可能要引入的文件中也有同样的常量，这时将会产生冲突。

常量一定要用static和const同时来修饰，使用const是为了防止篡改，如果篡改的话编译器将会报错，这是合理的，因为我们将之声明为常量就是希望它不会被更改，使用static是为了是这个常量的作用域限制在它的实现文件里(.m文件)，如果两个实现文件里同时声明了const float PI = 3.14这时将会报错。编译器会创建"外部符号"(external symbol)抛出:
	duplicate symb _PI in:
	XXX.o
	XXXXX.o

如果需要将某个常量暴露出来，此类变量需放在“全局符号表”中:
	//使用NSString * const 声明了常量指针
	//in the header file
	extern NSString *const PI;

	//in the implementation file
	NSString * const PO = 3.14

###5. 用枚举表示状态、选项、状态码

枚举的物种写法：
	
	enum EOCState {
	    EOCStatewait,
	    EOCStateRuning,
	    EOCStateEnd,
	};
	typedef enum EOCState EOCState;  
	//如果不加这句，在使用的时候要这么用e
	num EOCState state = EOCStateEnd;
	
	//上述方式的简写
	typedef enum: NSUInteger {
	    Monday,
	    Tuesday,
	    Wendnesday,
	} DayType;
	
	
	typedef enum : NSUInteger {
	    Admin   = 1 << 0,		//二进制表示为00000001
	    Normal  = 1 << 1,		//二进制表示为00000010
	} UserType;

	//NS_ENUM和NS_OPTIONS为系统的宏定义，具备向后兼容的能力，如果平台的编译器支持新标准即采用新语法，否则采用旧式语法。
	typedef NS_ENUM(NSUInteger, Day) {
	    Thurday,
	    Friday,
	};
	
	typedef NS_OPTIONS(NSUInteger, Direction) {
	    East    = 1 << 0,
	    South   = 1 << 1,
	    West    = 1 << 2,
	    North   = 1 << 3,
	};

	
##第二章 对象、消息、运行期

###6. 理解属性这一概念
一般语言中都会以这样的方式来定义类:
	class EOCPerson {
		public：
			NSString * firstname;
			NSString * lastname;
		private:
			UInt8 depositMoney;//年纪轻轻的我就有了8位数的存款
	}

在OC中就没有这个必要了，在编译后这些属性相对于类的"偏移量是固定的"，如果后来改变了类的结构就会导致访问错误。在OC中类的属性是放在类对象中，偏移量会在运行期时查找。某些实例变量以及与权限有关的属相可以放到分类中实现。

定义属性用@property关键字，它会自动生成一个实例变量和存取方法，实例变量命默认为_propertyname，可用@synthsize重新命名。存取方法也可以不自动生成，使用@dynamic告诉编译器不自动生成，采用自己生成的存取方法。

@property可以为属性定义四种特质:
	@property(nonatomic, assign, readwrite, getter = isSuccess) BOOL success;

第一个可为nonatomic和atomic(默认)，atomic为原子性，为属性的存取方法加入@synchronize(同步锁)防止多线程抢夺资源问题，但这并不能完全解锁多线程安全问题而且@synchronize还会非常耗性能，所以推荐使用nonatomic，使用更深层次的机制来解决线程访问安全。

第二个与内存管理相关，可选项有：

assign(默认):不持有该对象 对引用计数不影响，一般用于基础数据类型(非OC类对象)

weak:对对象所进行的操作和assign相似，表示不持有关系，但是在weak所指向的对象释放后，后自动置为nil，向nil发送消息时没有任何影响。

unsign_retained:同样和assign类型，但是用于OC对象，个人认为是和assign互补的。

retain:表示持有对象。

strong(默认):表示强引用，和retain所进行的操作一样，先retain新值，后释放旧值，再讲新值设置上去。但是能更好的体现语义。

copy:类似于strong，先retain新值，然后对旧值执行copy操作。此关键字可以防止一下情况-如果设置方法的新值为mutable类型话，属性的值可能就在无意间发生变动。

第三个指定权限可选项有readonly和readwrite(默认)，根据字面意思可知分别为只读与读写的，readonly只有获取方法。

第四个为读取方法重新命名。setter = xxx 一般不用。

值得注意的是当我们自定义存取方法以及在初始化方法中要符合描述属性的关键字，例如copy:

		-(void)firtname:(NSString *)name {
			_firstname = [name copy];
		}


		-(id)initWithFirstname:(NSString＊)firstname lastname:(NSString *)lastname {
			if (self = [super init]) {
				_firstname = [firstname copy];
				_lastname = [lastname copy];
			}
		}


###7.在类内部尽量使用实例变量
在不同情况下要使用不同的方法来访问属性,在读取实例变量的时候直接访问实例变量，而在设置实例变量的时候通过设置方法。下面是直接访问实例变量和通过存取方法来访问属性的对比:
1. 直接访问存取变量可以绕过方法派发(method dispatch)，跳过了这一步也就加快了访问速度。在这种情况下编译器会直接访问保存对象实例变量的那块内存。
2. 直接访问实例变量不会调用存取方法，绕过了相关属性的"内存管理语义"。例如copy。
3. 直接访问实例变量不会触发KVO
4. 通过存取方法来访问可以在方法中加入断点来调试。

第一种情况：在初始化方法中，尽量使用实例变量来设置值：
		//Test.h
		@interface Test 
		@property(nonatomic, copy) NSString * anme;
		-(id)init;
		@end
		
		//Test.m
		
		@implemention Test
		
		-(id)init {
			if (self = [super init]) {
				self.name = @"";
			}
			return self;
		}
		@end
		
		//SubTest.h
		
		@interface SubTest : Test
		
		@end
		
		//SubTest.m
		@implemention SubTest
		
		@synthsize name = _name;  //想想为什么需要这行代码。答案在后面。代码中会有提示
		
		-(void)setName:(NSString *)name {
			if (![name isEqualToString: @"subtest"]) {
				[NSException raise: NSInvalidArgumentException fromat: @"not subtest"];
			}
			//self.name = name;  //这里是是提示
			_name = name;
		}
		
		Test * test = [[Test alloc] init];			//在这里调用了自己的初始化方法
		NSLog(test.name);
		
		SubTest * subTest = [[SubTest alloc] init];	//这里调用的父类的初始化方法，在父类的初始化方法之是直接使用存取方法来设置属性的值的，然后在自己的设置方法中抛出了异常。如果把self.name = @"";改为_name = name;那么就不会抛出异常，但是名字并不是subtest。
		NSLog(subTest.name);

子类中无法直接使用父类通过property自动生成的实例变量,需要@synthsize来重新命名后方可使用，PS实例变量不可在类的外部使用，可通过存取方法来使用。

第二种情况：如果某个属性为lazy(懒加载),那么在使用这个属性时必须用获取方法来使用:

	-(NSString *)name {
		if (!_name) {
			_name = @"name";
		}
		return name;
	}
	
如果一直使用实例变量那么就不会用到获取方法，实例变量一直为空。

###8. 理解"对象等同性"这一概念
有三种方式来比较对象:
== 这种方式是直接比较指针。判断两个指针所指向的地址是否一样。

	isEqual 比较两个对象的属性是否相同,继承自NSObject。
	isEqualToString：某些对象提供的等同性判定方法，比较某个属性是否相同。
	
	NSString * str = @"123";
	NSString * str1 = [NSString stringWithFormat:@"%@", @"123"];
	
	BOOL isSameObject = str == str1;				//NO
	BOOL isEqual = [str isEqual: str1];				//YES
	BOOL isEqualStr = [str isEqualToString: str1];	//YES

NSObject中用于判断等同性（isEqual）的关键方法:

-(BOOL)siEqual:(id)object;
-(NSUInteger)hash;

NSObject类对这两个方法的默认实现是:当且仅当"指针值"完全相等时，这两个对象才相等。如果要在自己定义的类中正确覆写这些方法，必须先理解其约定。如果isEqual判断两个对象相等，那么hash方法必须返回相同的值，反之不一定成立。
	
		@class Person 
		@property firstname;
		@property lastname;
		@end
		
		-(BOOL)isEqual:(id)object {
		    if (self == object) {
		        return YES;
		    }
		    
		    if ([self class] != [object class]) {
		        return NO;
		    }
		    
		    Person * p = (Person *)object;
		    if (![firstname isEqualToSring: p.firsrname]) {
		        return NO;
		    }
		    if (![lastname isEqualToString: p.lastname]) {
		        return NO;
		    }
		    return YES;
		}

	-(NSUInteger)hash {
		return 1678；
	}

如果直接这样返回值虽然是可行的，但是有很大的隐患。如果将该类的对象加入集合collection中，假设这个collection为set，那么set回将同一个类的对象放到一个数组中，然后再插入新的对象的时候根据类来查找应该存放的数组，找到数组后再根据hash判断是否已经存在相同的对象了。如果set里有1w个该类的不同对象，那么就要遍历1w次。这是很耗性能的。我们再改进一下：

	-(NSUInteger)hash {
		NSString * str = [NSString　stringWithFormat:@"%@%@", _firstname, _lastname];
		return [str hash];
	}

这样来实现hash将会很复杂,每次都要进行字符串的创建，比较耗时。

	-(NSUInteger)hash {
		NSUInteger hash1 = [_firstname hash];
		NSUInteger hash2 = [_lastname hash];
		return hash1 ^ hash2;
	}

这样做虽然也不能保证一定不重复，但是在性能和碰撞频率上有了一个很好的平衡。

####特定类所具有的判等方法
在collection中，都有各类对应的判等方法，NSArray有isEqualToArray NSDictionary有isEqualToDictionary:,如果经常需要判断等同性，那么可以自己来创建等同性判断方法，因为无需判定参数类型，所以可以大大提高检测速度。在编写判定方法时，也应一并覆写isEqual:方法。

	-(BOOL)isEqualToPerson:(Person *)person {
	    if (self == person) {
	        return YES;
	    }
	    if (![self.firstname isEqualToString: person.firstname]) {
	        return NO;
	    }
	    if (![self.lastname isEqualToString: person.lastname]) {
	        return NO;
	    }
	    return YES;
	}
	
	-(BOOL)isEqual:(id)object {
	    if ([self class] == [object class]) {
	        return [self isEqualToPerson:(Person *)object];
	    } else {
	        return [super isEqual:object];
	    }
	}

####判等的执行深度
创建等同性判定方法时，是需要判断整个对象，还是具体某些属性，需要根据具体需求来决定。在数组中，isEqualToArray会比较两个数组的数量是否相同，然后再分别用isEqual比较相同下标的对象。有时候我们不需要比较每一个值都是相等的。比如有一波数据是从数据库中读取的，表中有对应的唯一id，这时候我们只需比较id是否相同，尤其是此属性声明为readonly时。

####容器内可变类的等同性
加入collection的可变对象的hash不应该再改变。

	NSMutableArray * arr = [@[1, 2, 3] mutableCopy];
	NSMutalbeSet * set = [NSMutalbeSet setWithArray: arr];
	NSArray * arr1 = [NSArray arrayWithObjects:@1, @2, @3, nil];
	[set addObject:arr1];			//这时候arr1是无法加入的
	
	NSMutableArray * arr2 = [NSMutableArray arrayWithObjects:@1, @2, nil];
	[set addObject: arr2];
	//set = ([@1, @2, @3], [@1, @2])
	[arr2 addObject: @3];
	//set = ([@1, @2, @3], [@1, @2, @3])这时候竟然有两个相同的对象在里面了。这与set的定义相悖。
	
	NSMutalbeSet * set1 = [set mutableCopy];
	//set = ([@1, @2, @3])	set1又变了。
	
###9. 	