---
title: Effective Objective-C 2.0 下
header: Effective Objective-C 2.0 下
description: 编写高质量iOS和OS X代码的52个有效方法 下
---

I love you not for who you are, but for who i am with you.

##第三章 接口与API设计
我们在开发过程中经常会想让一些代码可以在其他项目中重用，这时候我们希望能够将代码写的清晰一些，以便使用者可以快速准确的接入到项目中。
###第15条： 用前缀避免命名空间冲突
	duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:
		build/something.o
		build/somgthing_else.o
	duplicate symbol _OBJC_CLASS_$_EOCTheClass in:
		build/something.o
		build/something_else.o
错误在于出现了两个重名的类EOCTheClass
Objective-C中没有命名空间机制，所以避免此问题的唯一方式就是变相实现命名空间，为所有名称加上前缀，不仅是类名，包括分类和分类中方法。前缀可以是公司、项目、应用程序或者多者结合。注意苹果保留所有的"两字母前缀"，所以我们一般使用三个字母的前缀，以防止和苹果的名称冲突。开发者可能会忽视另外一个容易引发命名冲突的地方， 那就是类的实现文件中所用的纯C函数及全局变量。千万不要忘记：在编译好的目标文件中，这些名称是要算作"顶级符号"(top-level-symbol)的。
	
	//EOCSoundPlayer.h
	#import <Foundation/Foundation.h>
	
	@class EOCSoundPlayer;
	@protocol EOCSoundPlayerDelegate <NSObject>
	-(void)soundPlayerDidFinish:(EOCSoundPlayer *0)player;
	@end
	
	@interface EOCSoundPlayer: NSObject
	@property(nonatomic, weak) id <EOCSoundPlayerDelegate> delegate;
	-(id)initWithURL:(NSURL *)url;
	-(void)playSound;
	@end
	
	//EOCSoundPlayer.m
	#import "EOCSoundPlayer.h"
	#import <AudioToolbox/AudioToolbox.h>
	
	void completion(SystemSoundID ssID, void *clientData) {
		EOCSoundPlayer *player = (__bridge EOCSoundPlayer *)clientData;
		if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) {
			[player.delegate soundPlayerDidFinish:player];
		}
	}
	
	@implementation EOCSoundPlayer {
		SystemSoundID _systemSoundID;
	}
	
	-(id)initWithURL:(NSURL *)url {
		if (self = [super init]) {
			AudioServicesCreateSystemSound((__bridge CFURLRef)url, &_systemSoundID);
		}
		return self;
	}
	
	-(void)dealloc {
		AudioServicesDisposeSystemSoundID(_systemSoungID);
	}
	
	-(void)playSound {
		AudioServicesAddSystemSoundCompletion(_systemSoundID, NULL, NULL, completion, (__bridge void *)self);
		AudioServicesPlayerSystemSound(_systemSoundID);
	}
	
	@end
	
这段代码看上去完全正常，但是我们看看该类目标文件中的符号表(symbol table)，就会发现问题了：
	图片就不贴了，简单语言说明

就是在符号表中有个_completion的符号，虽然completion函数是在实现文件里定义的，并没有声明于头文件中。由此可见，我们总是应该给这种C函数的名字加上前缀。

如果用第三方库编写自己的代码，并准备将其发布给别人使用，如果你的程序库包含了别的三方库，那么你需要为这些三方库都加上自己的前缀。如果不改，那么别的使用者在引入你的库和那个三方库的时候就回发生冲突。

###第16条：提供"全能初始化方法"

在编写类的初始化方法时要提供一个全能初始化方法，然后其他的任意初始化方法都要调用这个全能方法。

在子类中可以重新指定全能初始化方法，但是一定要覆写超类的全能方法。在实现覆写时可以调用新的初始化方法。另外一个类可能会有不止一个全能方法。每个子类的全能初始化方法需要调用其超类的对应方法。

###第十七条 实现description方法

一般我们在程序运行时想要查看某个对象的具体内容时，会使用NSLog(classInstance)来查看，对于一些系统类尤其是数组字典等集合时会打印出其具体信息，但是对于自定义的类，只会打印出地址信息，这时候我们可以实现description，此方法定义在NSObject协议中

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, name = %@, age = %@>", [self class], self, _name, _age];
	}
	
还有更简单的方式,这里借助了NSDictionary的description方法。

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, %@>", [self class], self, @{"name": _name, "age":@(_age)}];
	}
	
NSObject协议中还有一个方法要注意，debugDescription方法与上一方法很相似，这个方法会在控制台调用po命令时会调用它。

###尽量使用不可变对象

在设计类的时候，建模的数据未必需要改变。这个是我们就要把属性声明为不可变类型，在具体实践时，应该尽量把属性对外声明为只读，并且只在必要时才对象公布。

举一个栗子，现在有个类要处理地图上的景点，数据从网络获取，一开始回这样写:
	
	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy) NSString *identifier;
	@property (nonatomic, copy) NSString *title;
	@property (nonatomic, assign) float latitude;	@property (nonatomic, assign) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
获取到值后就无需改动了，在其他语言中可能需要将这些属性设置为私有属性，在OC中就不需要考虑这个东西。

	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy, readonly) NSString *identifier;
	@property (nonatomic, copy, readonly) NSString *title;
	@property (nonatomic, assign, readonly) float latitude;	@property (nonatomic, assign, readonly) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
如果尝试改变属性的值的话，编译器则会报错。有人会问既然已经没有存储方法，那么这些内存管理语义也没有意义了，虽然在这里没有意义，但是如果日后需要改变为可变属性的时候就不需要添加了。我觉得还有一点，就是在初始化方法里面内存管理语义也会有影响的。待考证

有时候我们想在类的内部改变属性，而让它外部无法被更改，这时候我们可以在类的内部重新声明为可写的，而对外部仍为只读。但是要注意竞争问题，当我在内部写入的时候，外部正好也在读取，可以通过派发队列来解决。

属性在内部重新声明为readwrite在分类中完成，在公共接口中声明的属性可于此处重新声明，其他特质必须保持不变，而readonly可扩展未readwrite。

但是在对象外部仍可KVC来设置这些属性值。因为KVC会在类中查找set方法，甚至有的人会使用类型信息查询功能在类中查找属性的偏移量，然后直接更改偏移量的值。这些杂技代码都是不可取的。

如果外部需要改变值的话，也尽量不对外声明为可写，而是通过其他方法。比如Person有friends属性，外部可添加删除。
		
	@interface Person: NSObject
	@property (nonatomic, copy, readonly) NSString * name;
	@property (nonatomic, strong, readonly) NSSet * friends;
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends;
	
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	
	@end
	
	#import "Person.h"
	@interface Person()
	@property (nonatomic, copy, readwrite) NSString * name;
	@property (nonatomic, strong, readwrite) NSSet * friends;
	
	@implementation Person {
		NSMutalbeSet * _internalFriends;
	}
	
	-(NSSet *)friends {
		return [_internalFriedns copy];
	}
	
	-(void)addFriend:(Person *)perspn {
		[_internalFriends addObject: person];
	}
	
	-(void)removeFriend:(Person *)persom]n {
		[_internalFriends removeObject: person];
	}
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends {
		if(self = [super init]) {
			_name = name;
			_internalFriends = [NSMutalbeSet new];
		}	
		return self;
	}
	
	@end
	
不要在返回的对象上查询类型以确定对象是否可变，在上一例子中，获取方法直接返回了可变对象，这是合理的，因为存储对象可能回很大导致copy操作耗时，所以直接返回，语法上来看NSMutableSet是NSSet的子类，所以也是合理的。

	Person * person = [Peroson new];
	NSSet * friends = person.friedns;
	if ([friedns isKindOfClass: [NSMutabkle class]]) {
		...
	}
	
尽量不要这么做，不宜直接从底层修改数据。

###19.


##第四章协议与分类

###23. 通过委托与数据源协议进行对象间通信

1. 此模式可将数据与业务逻辑解耦 概念

2. 内存管理语义 循环引用
一般使用weak 也可使用unsafe_unretained不过weak在对象释放后会置为nil,而unsafe_unretained则不会。若使用strong则会产生保留环。

3. 权限问题:
如果要向外界公布此类实现了某协议，那么则在接口中声明，而如果这个协议为委托协议的话，那么通常只会在类的内部使用，则在分类中声明。

4. 可选V必须实现
由于协议里的方法不一定都得实现，所以提供了@optional关键字来声明可选方法。既然有可选方法，那么遵守该协议的类就可能不会实现某些方法，那么在使用之前要加个判断
	
	if ([delegate respondsToSelector: @selector(doSomething)]) {
		[delegate doSomething];
	}

调用方法之前先判断该方法是否实现则会避免问题，即便delegate为空也不会发生问题，因为向nil发送消息会返回false。

5. 数据源模式

也可以定义一套接口，从而实现从该接口获取数据。委托模式的这一用法旨在向类提供数据，故而又称"数据源模式"。

6. 协议方法实现以及缓存(位段)

第四点提到调用之前先判断，如果某一方法频繁调用的话，除了第一次检测的结果有用之外，那么后续的每次判断都是多余的，将会影响性能。所以考虑将他缓存起来。
	
	//ViewController.h
	@protocol TestDelegate

	@optional
	-(void)printTest1;
	-(void)printTest2;
	-(void)printTest3;
	
	@end
	
	@interface ViewController : UIViewController <TestDelegate>
	@end
	
	
	//Test.h
	@interface Test : NSObject
	@property(nonatomic, weak) id<TestDelegate> delegate;
	
	
	//Test.m
	@interface Test()
	{
	    struct {
	        unsigned int printTest1 : 1;
	        unsigned int printTest2 : 1;
	        unsigned int printTest3 : 1;
	    } _delegateFlags;
	}
	
	@end
	
	@implementation Test
	
	-(void)setDelegate:(id)delegate {
	    _delegate = delegate;
	    _delegateFlags.printTest1 = [delegate respondsToSelector:@selector(printTest1)];
	    _delegateFlags.printTest2 = [delegate respondsToSelector:@selector(printTest2)];
	    _delegateFlags.printTest3 = [delegate respondsToSelector:@selector(printTest3)];
	}
	
	-(void)create {
	    if (_delegateFlags.printTest1) {
	        [_delegate printTest1];
	    }
	}
	
在相关代码要调用很多次时，值得进行这种优化。而是否需要进行这种优化，具体情况具体对待。

###24. 将类的实现代码分散到便于管理的数个分类之中

方便管理和阅读，在打印的时候回输出分类的信息

一个类中可能会塞满各种方法，然后全部堆在实现文件里，可通过Objective-C的分类机制按逻辑划分到几个分区中。

	@interface Person: NSObject
	@property (nonatomic, copy, readonly) NSString ＊ name;
	@property (nonatomic, strong, readonly) NSArray ＊ friends;
	-(id)initWithName:(NSString *)name;

	//Friendship methods
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	
	//work mothods
	-(void)performDaysWork;
	-(void)takeVacationFromWork;
	
	//paly methods
	-(void)goToTheCinema;
	-(void)goToSportsGame;

	@end

	@interface Peoson: NSObject
	@property (nonatomic, copy, readonly) NSString ＊ name;
	@property (nonatomic, strong, readonly) NSArray ＊ friends;
	-(id)initWithName:(NSString *)name;
	@end

	@interface Person(Friend)
	//Friendship methods
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	@end

	@interface Person(Work)
	//work mothods
	-(void)performDaysWork;
	-(void)takeVacationFromWork;
	@end


	@interface Person(Play)
	//paly methods
	-(void)goToTheCinema;
	-(void)goToSportsGame;
1. 1. 	@end

也可以放到不同的文件中。可以创建名为Private的分类，把应该视为私有的方法全都放入这个分类中，这样类的使用者在查看回溯信息时会发现private，然后意识到这是私有方法，不应该调用。


###25. 总是为第三方的类的分类名称加前缀

分类机制通常用于向无源码的既有类中添加功能。分类中的方法会覆盖原有的同名方法，多个分类中的同名方法，最后一个加入的会覆盖之前的。分类中的方法是直接添加到类中的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。

	@interface NSString (ABC_HTTP)
	-(NSString *)abc_urlEncodedString;
	@end

两个分类重名，虽然不会出错但是会发出重复定义的警告，如果不加前缀，别人的分类和你的重名，在你调用分类的方法时那么可能会发生无法预料的结果。


###26. 不要在分类中添加属性

在24小节中说将类的实现代码分散到分类中去，然后我们是否可以把属性也分散到分类中去呢，最好不要。除了"class-continuation分类"外,其他分类都无法向类中新增实例变量。

	@interface Person: NSObject
	@property (nonatomic, copy, readonly) NSString ＊ name;
	@end

	@interface Person(Friend)
	@property (nonatomic, strong, readonly) NSArray ＊ friends;
	@end

虽然可以在分类中添加属性，但是并不会自动生成实例变量。编译器会给出警告，告诉你词分类无法合成friends属性相关的实例变量，需要开发者自己为该属性实现存取方法。此时可以把存取方法声明为@dynamic。等到运行期在提供，编译器是看不见的，如果决定使用消息转发机制在运行期拦截方法调用，并提供其实现。

我们可以通过关联对象来自己实现这个机制

	static const NSString * KFriendKey = "selfFriends"
	-(void)setFriends:(NSArray *)friends {
		objc_setAssociatedObject(self, KFriendKey, friends, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
	}
	
	-(id)friends {
		return objc_getAssociatedObject(self, KFriendKey);
	}
	
在实现内存管理时也会很容易出错，在声明属性的地方更改了内存管理语义时，在其设置方法中也需要更改，这是很容易忘记的一点。

在分类中我们可以添加只读属性:

	@interface Canlendar (EOC_Additions) 
	@property(nonatomic, strong, readonly) NSArray * eoc_allMonths;
	@end 
	
	@implemention Calendar (EOC_Additions)
	-(NSArray *)eoc_allMonths {
		return @[@"January", @"February"...];
	}

属性是用来封装数据的，它要表达的意思是：类中有数据在支持着它，所以在本例中直接声明一个方法就好了。


###27. 

私有方法 协议

我们可以在类的公共接口中声明一些属性，然后写明其为私有，Objective-C动态消息系统的工作让类没有真正私有的方法和属性。我们最好还是把只需公开的内容公开。"class-continuation分类就可以实现这点"

	//.h
	@interface Woman: NSObject {
	}
	@end

	//.m
	@interface Woman () {
		NSString * _someInstance;	
	}
	@property(nonatomic, assign) int age;
	@end
	
	//实现块中也可以增加实例变量，但是为了保持一致所以都一起放在分类中
	@implemention Woman {
		Double weight;
	}

把实例变量定义在分类中活实现块中，可以将其隐藏起来，只供本类使用。即便使用@private标注也会暴露细节，比如有个绝密的类，不想让外人知道，然后我们把它声明在公共接口中:
	
	//.h
	@interface Woman: NSObject {
	@private
		SecretClass * _secretClass;
	}
	@end
	
那么这样就暴露了这个类的存在。即使可以使用id来代替SecretClass *，但是这要编译器就无法提供一些辅助检查，所以这时放入分类中最好。

在编写Objective-C++时，分类也很有用。

	#include "SomeCppClass.h"
	
	@interfac EOCClass: NSObject {
	@private
		SomeCppClass _someCppInstance;
	}
	@end
	
这个类的实现文件应该是.mm， 这个.mm表示将这个类叫个Objective-C++的编译器来编译，否则无法正确引入SomeCppClass。名为SomeCppClass的C++类必须完全引入，因为编译器必须完整解析其定义才能确定_someCppInstance的大小，于是只要包含EOCClass的类都必须由ObjectiveC++编译器来编译。你可能认为不引入C++类的头文件，而是向前声明，并且将实例变量改为指针。

	class SomeCppClass
	@interfac EOCClass: NSObject {
	@private
		SomeCppClass * _someCppInstance;
	}
	@end

现在实例变量为指针，指针大小是固定的，编译器只需知道指针所指向的类型即可。但是引入EOCClass的文件里都包含class关键字，而这个字是C++的关键字，所以还是得按Objective-C++来编译。最后还是得用分类来解决。

	//.m
	#include "SomeCppClass.h"
	
	@interfac EOCClass () {
		SomeCppClass _someCppInstance;
	}
	@end
	
还有一种合理用法，之前有提过，就是讲公共接口中的只读属性重新声明为读写属性(第七条)。在类的实现代码中尽量用设置方法来给属性设置新的值，而不是通过实例变量，因为设置方法才会触发KVO的方法。
	
	//.h
	@interface Person: NSObject
	@property(nonatomic, copy, readonly) NSString * name;
	@end

	//.m
	@interface Person()
	@property(nonatomic, copy, readwrite) NSString * name;
	@end
	
第18条曾详述过这个话题，若观察者正在读取该值同时内部代码在写入新值，则有可能引发"竞争条件"，合理使用同步机制能解决此问题。

私有方法也可以声明在分类中，

	@interface Person ()
	-(void)p_privateMethod;
	@end

把类中的所有方法都描述于此，更易读懂。

最后一种用法，若对象所遵从的协议只视为私有，那么就在分类中声明。总之分类就是把不想暴露的东西隐藏起来。


###28. 通过协议提供匿名对象

这节其实没什么好说的，主要就是

	@property (nonatomic, weak) id <someDelegate> delegate;
	
这就是匿名对象，和C++中的匿名不是一个意思。只关心这个对象是否遵循了某个协议，而不关心具体是哪个对象。隐藏了具体实现细节。


