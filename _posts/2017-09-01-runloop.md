---
title: runloop
header: runloop
desciption: runloop
---

RunLoop的目的就是保证程序一直运行 不退出
其原理就是内部的一个无限循环。
具体运行中:
1. 保证程序的持续运行
2. 处理APP中的各种事件(比如触摸事件、定时器、selector)
3. 节省CPU资源，有任务处理任务 空闲时休眠

* 每个线程都有且只有一个RunLoop与之对应
* 主线程中的RunLoop是自动创建的其他子线程需要手动创建
* 线程刚创建时并没有RunLoop，如果不主动获取。RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）


CFRunLoopRef
CFRunLoopModeRef
CFRunLoopSourceRef
CFRunLoopTimeRef
CFRunLoopObserverRef

* CFRunLoopSourceRef
按照官方文档的分类
Port-Based source
Custom-Input source
Cocoa Perform selector source
按函数调用栈可以分类为:
source0 非基于port的
source1 基于port

* CFRunLoopTimeSource

基本上可以说就是NSTimer gcd的定时器是不受影响的

* CFRunLoopObserverRef

		typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
		    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop     （1）
		    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer   （2）
		    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source  （4）
		    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠      （32）
		    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒     (64)
		    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop      (128)
		    kCFRunLoopAllActivities = 0x0FFFFFFU, // 包含上面所有状态
		
		};


* CFRunLoopModeRef

NSDefaultRunLoopMode: 默认模式 通常主线程是在这个模式下运行
UITrackingRunLoopMode 界面跟踪mode 用于UIScrollView滑动，保证界面滑动不受其他model影响
UIInitializationRunLoopMode: 在刚启动APP时进入的第一个mode，启动完成后就不再使用
GSEventReceiveRunLoopMode接受系统内部事件的mode通常用不到 貌似也没有开放
NSRunLoopCommonMode

NSRunLoop运行时的流程 简化来说就是先做一些准备工作是自己准备接受一些工作，做好准备工作后看看有没有工作要做，如果没有就让自己休眠。直到有任务过来。如果有工作就直接开始工作

具体步骤如下:

1. 通知观察者run loop已经启动
2. 通知观察者任即将要开始的定时器
3. 通知观察者任何即将启动的非基于端口的源(source0)
4. 启动任何准备好的非基于端口的源(source1)
5. 如果基于端口的源准备好处于等待状态，立即启动;并进入步骤9。
6. 通知观察者线程进入休眠
7. 将线程置于休眠直到任一下面的事件发生
	
	+ 某一事件到达基于端口的源
	+ 定时器启动
	+ run loop设置的时间已经超时
	+ run loop已经显示唤醒

8. 通知观察者线程被唤醒
9. 处理未处理的事件

	+ 如果用户定义的定时器启动，处理定时器事件并重启run loop 返回步骤2*
	+ 如果run loop被显示唤醒并时间还没超时，重启run loop 进入步骤2*
	
10. 通知观察者run loop结束

### iOS通过RunLoop实现的功能

#### AutoReleasPool

#### 事件相应
apple注册了一个source1(基于mach port的)用来接收系统事件，
当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由IOKit.framwork生成一个IOHIDEvent事件并由SpringBoard接受。SpringBoard只接受按键(锁屏/静音等)，触摸，加速，接近传感器等几种Event，随后用mach port转发给需要的App进程。随后苹果注册的那个Source1就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用的内部的分发。

_UIApplicationHandleEventQueue()会把IOHIDEvent处理并包装成UIEvent进行处理或分发，其中包括识别UIGesture/处理屏幕旋转/发送给UIWindow等。通常事件比如UIButton点击、touchesBegin/Move/End/Cancel事件都是在这个回调中完成的。

#### 手势识别
当上面的_UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用Cancel将当前的touchesBegin/Move/End系列回调打断。随后系统将对应的UIGestureRecognizer标记为待处理。

苹果注册了一个Observer检测BeforeWaiting(Loop即将进入休眠)事件，这个Observer的回调函数是_UIGestureRecognizerUpdateObserver(),其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer的回调。

当有UIGestureRecognizer的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

#### 界面更新
当在操作UI时，比如改变了Frame、更新了UIView/CALayer的层次时，或者手动调用了UIView/CALayer的setNeedsLayout/setNeedsDisplay方法后，这个UIView/CALayer就被标记为待处理，并被提交到一个全局的容器中去。

苹果注册了一个Observer监听BeforeWaiting(即将进入休眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:
[这里有一篇关于界面刷新的问题](https://www.jianshu.com/p/d46bcc656e04)

#### 定时器
NSTimer其实就是一个CFRunLoopTimerRef，他们之间是toll-free bridged的。一个NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册好事件。例如10：00 10：10 10：20这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer有个属性叫做Tolerance(容忍度)，标示了当时间点到后，容忍有多少时间误差。如果某个时间点过去后，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果10：10时我忙着玩手机错过了那个点的公交，那我只能等10：20这一趟了。

CADisplayLink是一个和屏幕刷新率一致的定时器(但实际实现原理更复杂，和NSTimer并不一样，其内部实际是操作了一个Source)如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去(和NSTimer相似)，造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。FaceBook开源的AsyncDisplayLink就是为了解决界面卡顿的问题，其内部也用到了RunLoop。




[深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)

[22](http://www.jianshu.com/p/d260d18dd551)