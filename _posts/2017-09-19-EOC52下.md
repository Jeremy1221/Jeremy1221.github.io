---
title: Effective Objective-C 2.0 下
header: Effective Objective-C 2.0 下
description: 编写高质量iOS和OS X代码的52个有效方法 下
---

I love you not for who you are, but for who i am with you.

##第三章 接口与API设计
我们在开发过程中经常会想让一些代码可以在其他项目中重用，这时候我们希望能够将代码写的清晰一些，以便使用者可以快速准确的接入到项目中。
###第15条： 用前缀避免命名空间冲突
	duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:
		build/something.o
		build/somgthing_else.o
	duplicate symbol _OBJC_CLASS_$_EOCTheClass in:
		build/something.o
		build/something_else.o
错误在于出现了两个重名的类EOCTheClass
Objective-C中没有命名空间机制，所以避免此问题的唯一方式就是变相实现命名空间，为所有名称加上前缀，不仅是类名，包括分类和分类中方法。前缀可以是公司、项目、应用程序或者多者结合。注意苹果保留所有的"两字母前缀"，所以我们一般使用三个字母的前缀，以防止和苹果的名称冲突。开发者可能会忽视另外一个容易引发命名冲突的地方， 那就是类的实现文件中所用的纯C函数及全局变量。千万不要忘记：在编译好的目标文件中，这些名称是要算作"顶级符号"(top-level-symbol)的。
	
	//EOCSoundPlayer.h
	#import <Foundation/Foundation.h>
	
	@class EOCSoundPlayer;
	@protocol EOCSoundPlayerDelegate <NSObject>
	-(void)soundPlayerDidFinish:(EOCSoundPlayer *0)player;
	@end
	
	@interface EOCSoundPlayer: NSObject
	@property(nonatomic, weak) id <EOCSoundPlayerDelegate> delegate;
	-(id)initWithURL:(NSURL *)url;
	-(void)playSound;
	@end
	
	//EOCSoundPlayer.m
	#import "EOCSoundPlayer.h"
	#import <AudioToolbox/AudioToolbox.h>
	
	void completion(SystemSoundID ssID, void *clientData) {
		EOCSoundPlayer *player = (__bridge EOCSoundPlayer *)clientData;
		if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) {
			[player.delegate soundPlayerDidFinish:player];
		}
	}
	
	@implementation EOCSoundPlayer {
		SystemSoundID _systemSoundID;
	}
	
	-(id)initWithURL:(NSURL *)url {
		if (self = [super init]) {
			AudioServicesCreateSystemSound((__bridge CFURLRef)url, &_systemSoundID);
		}
		return self;
	}
	
	-(void)dealloc {
		AudioServicesDisposeSystemSoundID(_systemSoungID);
	}
	
	-(void)playSound {
		AudioServicesAddSystemSoundCompletion(_systemSoundID, NULL, NULL, completion, (__bridge void *)self);
		AudioServicesPlayerSystemSound(_systemSoundID);
	}
	
	@end
	
这段代码看上去完全正常，但是我们看看该类目标文件中的符号表(symbol table)，就会发现问题了：
	图片就不贴了，简单语言说明

就是在符号表中有个_completion的符号，虽然completion函数是在实现文件里定义的，并没有声明于头文件中。由此可见，我们总是应该给这种C函数的名字加上前缀。

如果用第三方库编写自己的代码，并准备将其发布给别人使用，如果你的程序库包含了别的三方库，那么你需要为这些三方库都加上自己的前缀。如果不改，那么别的使用者在引入你的库和那个三方库的时候就回发生冲突。