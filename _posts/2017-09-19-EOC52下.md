---
title: Effective Objective-C 2.0 下
header: Effective Objective-C 2.0 下
description: 编写高质量iOS和OS X代码的52个有效方法 下
---

I love you not for who you are, but for who i am with you.

##第三章 接口与API设计
我们在开发过程中经常会想让一些代码可以在其他项目中重用，这时候我们希望能够将代码写的清晰一些，以便使用者可以快速准确的接入到项目中。
###第15条： 用前缀避免命名空间冲突
	duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:
		build/something.o
		build/somgthing_else.o
	duplicate symbol _OBJC_CLASS_$_EOCTheClass in:
		build/something.o
		build/something_else.o
错误在于出现了两个重名的类EOCTheClass
Objective-C中没有命名空间机制，所以避免此问题的唯一方式就是变相实现命名空间，为所有名称加上前缀，不仅是类名，包括分类和分类中方法。前缀可以是公司、项目、应用程序或者多者结合。注意苹果保留所有的"两字母前缀"，所以我们一般使用三个字母的前缀，以防止和苹果的名称冲突。开发者可能会忽视另外一个容易引发命名冲突的地方， 那就是类的实现文件中所用的纯C函数及全局变量。千万不要忘记：在编译好的目标文件中，这些名称是要算作"顶级符号"(top-level-symbol)的。
	
	//EOCSoundPlayer.h
	#import <Foundation/Foundation.h>
	
	@class EOCSoundPlayer;
	@protocol EOCSoundPlayerDelegate <NSObject>
	-(void)soundPlayerDidFinish:(EOCSoundPlayer *0)player;
	@end
	
	@interface EOCSoundPlayer: NSObject
	@property(nonatomic, weak) id <EOCSoundPlayerDelegate> delegate;
	-(id)initWithURL:(NSURL *)url;
	-(void)playSound;
	@end
	
	//EOCSoundPlayer.m
	#import "EOCSoundPlayer.h"
	#import <AudioToolbox/AudioToolbox.h>
	
	void completion(SystemSoundID ssID, void *clientData) {
		EOCSoundPlayer *player = (__bridge EOCSoundPlayer *)clientData;
		if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) {
			[player.delegate soundPlayerDidFinish:player];
		}
	}
	
	@implementation EOCSoundPlayer {
		SystemSoundID _systemSoundID;
	}
	
	-(id)initWithURL:(NSURL *)url {
		if (self = [super init]) {
			AudioServicesCreateSystemSound((__bridge CFURLRef)url, &_systemSoundID);
		}
		return self;
	}
	
	-(void)dealloc {
		AudioServicesDisposeSystemSoundID(_systemSoungID);
	}
	
	-(void)playSound {
		AudioServicesAddSystemSoundCompletion(_systemSoundID, NULL, NULL, completion, (__bridge void *)self);
		AudioServicesPlayerSystemSound(_systemSoundID);
	}
	
	@end
	
这段代码看上去完全正常，但是我们看看该类目标文件中的符号表(symbol table)，就会发现问题了：
	图片就不贴了，简单语言说明

就是在符号表中有个_completion的符号，虽然completion函数是在实现文件里定义的，并没有声明于头文件中。由此可见，我们总是应该给这种C函数的名字加上前缀。

如果用第三方库编写自己的代码，并准备将其发布给别人使用，如果你的程序库包含了别的三方库，那么你需要为这些三方库都加上自己的前缀。如果不改，那么别的使用者在引入你的库和那个三方库的时候就回发生冲突。

###第16条：提供"全能初始化方法"

在编写类的初始化方法时要提供一个全能初始化方法，然后其他的任意初始化方法都要调用这个全能方法。

在子类中可以重新指定全能初始化方法，但是一定要覆写超类的全能方法。在实现覆写时可以调用新的初始化方法。另外一个类可能会有不止一个全能方法。每个子类的全能初始化方法需要调用其超类的对应方法。

###第十七条 实现description方法

一般我们在程序运行时想要查看某个对象的具体内容时，会使用NSLog(classInstance)来查看，对于一些系统类尤其是数组字典等集合时会打印出其具体信息，但是对于自定义的类，只会打印出地址信息，这时候我们可以实现description，此方法定义在NSObject协议中

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, name = %@, age = %@>", [self class], self, _name, _age];
	}
	
还有更简单的方式,这里借助了NSDictionary的description方法。

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, %@>", [self class], self, @{"name": _name, "age":@(_age)}];
	}
	
NSObject协议中还有一个方法要注意，debugDescription方法与上一方法很相似，这个方法会在控制台调用po命令时会调用它。

###尽量使用不可变对象

在设计类的时候，建模的数据未必需要改变。这个是我们就要把属性声明为不可变类型，在具体实践时，应该尽量把属性对外声明为只读，并且只在必要时才对象公布。

举一个栗子，现在有个类要处理地图上的景点，数据从网络获取，一开始回这样写:
	
	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy) NSString *identifier;
	@property (nonatomic, copy) NSString *title;
	@property (nonatomic, assign) float latitude;	@property (nonatomic, assign) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
获取到值后就无需改动了，在其他语言中可能需要将这些属性设置为私有属性，在OC中就不需要考虑这个东西。

	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy, readonly) NSString *identifier;
	@property (nonatomic, copy, readonly) NSString *title;
	@property (nonatomic, assign, readonly) float latitude;	@property (nonatomic, assign, readonly) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
如果尝试改变属性的值的话，编译器则会报错。有人会问既然已经没有存储方法，那么这些内存管理语义也没有意义了，虽然在这里没有意义，但是如果日后需要改变为可变属性的时候就不需要添加了。我觉得还有一点，就是在初始化方法里面内存管理语义也会有影响的。待考证

有时候我们想在类的内部改变属性，而让它外部无法被更改，这时候我们可以在类的内部重新声明为可写的，而对外部仍为只读。但是要注意竞争问题，当我在内部写入的时候，外部正好也在读取，可以通过派发队列来解决。

属性在内部重新声明为readwrite在分类中完成，在公共接口中声明的属性可于此处重新声明，其他特质必须保持不变，而readonly可扩展未readwrite。

但是在对象外部仍可KVC来设置这些属性值。因为KVC会在类中查找set方法，甚至有的人会使用类型信息查询功能在类中查找属性的偏移量，然后直接更改偏移量的值。这些杂技代码都是不可取的。

如果外部需要改变值的话，也尽量不对外声明为可写，而是通过其他方法。比如Person有friends属性，外部可添加删除。
		
	@interface Person: NSObject
	@property (nonatomic, copy, readonly) NSString * name;
	@property (nonatomic, strong, readonly) NSSet * friends;
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends;
	
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	
	@end
	
	#import "Person.h"
	@interface Person()
	@property (nonatomic, copy, readwrite) NSString * name;
	@property (nonatomic, strong, readwrite) NSSet * friends;
	
	@implementation Person {
		NSMutalbeSet * _internalFriends;
	}
	
	-(NSSet *)friends {
		return [_internalFriedns copy];
	}
	
	-(void)addFriend:(Person *)perspn {
		[_internalFriends addObject: person];
	}
	
	-(void)removeFriend:(Person *)persom]n {
		[_internalFriends removeObject: person];
	}
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends {
		if(self = [super init]) {
			_name = name;
			_internalFriends = [NSMutalbeSet new];
		}	
		return self;
	}
	
	@end
	
