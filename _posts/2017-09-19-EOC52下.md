---
title: Effective Objective-C 2.0 下
header: Effective Objective-C 2.0 下
description: 编写高质量iOS和OS X代码的52个有效方法 下
---

I love you not for who you are, but for who i am with you.

##第三章 接口与API设计
我们在开发过程中经常会想让一些代码可以在其他项目中重用，这时候我们希望能够将代码写的清晰一些，以便使用者可以快速准确的接入到项目中。
###第15条： 用前缀避免命名空间冲突
	duplicate symbol _OBJC_METACLASS_$_EOCTheClass in:
		build/something.o
		build/somgthing_else.o
	duplicate symbol _OBJC_CLASS_$_EOCTheClass in:
		build/something.o
		build/something_else.o
错误在于出现了两个重名的类EOCTheClass
Objective-C中没有命名空间机制，所以避免此问题的唯一方式就是变相实现命名空间，为所有名称加上前缀，不仅是类名，包括分类和分类中方法。前缀可以是公司、项目、应用程序或者多者结合。注意苹果保留所有的"两字母前缀"，所以我们一般使用三个字母的前缀，以防止和苹果的名称冲突。开发者可能会忽视另外一个容易引发命名冲突的地方， 那就是类的实现文件中所用的纯C函数及全局变量。千万不要忘记：在编译好的目标文件中，这些名称是要算作"顶级符号"(top-level-symbol)的。
	
	//EOCSoundPlayer.h
	#import <Foundation/Foundation.h>
	
	@class EOCSoundPlayer;
	@protocol EOCSoundPlayerDelegate <NSObject>
	-(void)soundPlayerDidFinish:(EOCSoundPlayer *0)player;
	@end
	
	@interface EOCSoundPlayer: NSObject
	@property(nonatomic, weak) id <EOCSoundPlayerDelegate> delegate;
	-(id)initWithURL:(NSURL *)url;
	-(void)playSound;
	@end
	
	//EOCSoundPlayer.m
	#import "EOCSoundPlayer.h"
	#import <AudioToolbox/AudioToolbox.h>
	
	void completion(SystemSoundID ssID, void *clientData) {
		EOCSoundPlayer *player = (__bridge EOCSoundPlayer *)clientData;
		if ([player.delegate respondsToSelector:@selector(soundPlayerDidFinish:)]) {
			[player.delegate soundPlayerDidFinish:player];
		}
	}
	
	@implementation EOCSoundPlayer {
		SystemSoundID _systemSoundID;
	}
	
	-(id)initWithURL:(NSURL *)url {
		if (self = [super init]) {
			AudioServicesCreateSystemSound((__bridge CFURLRef)url, &_systemSoundID);
		}
		return self;
	}
	
	-(void)dealloc {
		AudioServicesDisposeSystemSoundID(_systemSoungID);
	}
	
	-(void)playSound {
		AudioServicesAddSystemSoundCompletion(_systemSoundID, NULL, NULL, completion, (__bridge void *)self);
		AudioServicesPlayerSystemSound(_systemSoundID);
	}
	
	@end
	
这段代码看上去完全正常，但是我们看看该类目标文件中的符号表(symbol table)，就会发现问题了：
	图片就不贴了，简单语言说明

就是在符号表中有个_completion的符号，虽然completion函数是在实现文件里定义的，并没有声明于头文件中。由此可见，我们总是应该给这种C函数的名字加上前缀。

如果用第三方库编写自己的代码，并准备将其发布给别人使用，如果你的程序库包含了别的三方库，那么你需要为这些三方库都加上自己的前缀。如果不改，那么别的使用者在引入你的库和那个三方库的时候就回发生冲突。

###第16条：提供"全能初始化方法"

在编写类的初始化方法时要提供一个全能初始化方法，然后其他的任意初始化方法都要调用这个全能方法。

在子类中可以重新指定全能初始化方法，但是一定要覆写超类的全能方法。在实现覆写时可以调用新的初始化方法。另外一个类可能会有不止一个全能方法。每个子类的全能初始化方法需要调用其超类的对应方法。

###第十七条 实现description方法

一般我们在程序运行时想要查看某个对象的具体内容时，会使用NSLog(classInstance)来查看，对于一些系统类尤其是数组字典等集合时会打印出其具体信息，但是对于自定义的类，只会打印出地址信息，这时候我们可以实现description，此方法定义在NSObject协议中

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, name = %@, age = %@>", [self class], self, _name, _age];
	}
	
还有更简单的方式,这里借助了NSDictionary的description方法。

	-(NSString *)description {
		return [NSString stringWithFormat:@"<%@ --> %p, %@>", [self class], self, @{"name": _name, "age":@(_age)}];
	}
	
NSObject协议中还有一个方法要注意，debugDescription方法与上一方法很相似，这个方法会在控制台调用po命令时会调用它。

###尽量使用不可变对象

在设计类的时候，建模的数据未必需要改变。这个是我们就要把属性声明为不可变类型，在具体实践时，应该尽量把属性对外声明为只读，并且只在必要时才对象公布。

举一个栗子，现在有个类要处理地图上的景点，数据从网络获取，一开始回这样写:
	
	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy) NSString *identifier;
	@property (nonatomic, copy) NSString *title;
	@property (nonatomic, assign) float latitude;	@property (nonatomic, assign) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
获取到值后就无需改动了，在其他语言中可能需要将这些属性设置为私有属性，在OC中就不需要考虑这个东西。

	@interface PointOfInterest: NSObject 
	
	@property (nonatomic, copy, readonly) NSString *identifier;
	@property (nonatomic, copy, readonly) NSString *title;
	@property (nonatomic, assign, readonly) float latitude;	@property (nonatomic, assign, readonly) NSString longitude;
		
	- (id) initWithIdentifier: (NSString *)identifier title:(NSString *)title, latitude:(float)latitude longitude:(float)longitude

	@end
	
如果尝试改变属性的值的话，编译器则会报错。有人会问既然已经没有存储方法，那么这些内存管理语义也没有意义了，虽然在这里没有意义，但是如果日后需要改变为可变属性的时候就不需要添加了。我觉得还有一点，就是在初始化方法里面内存管理语义也会有影响的。待考证

有时候我们想在类的内部改变属性，而让它外部无法被更改，这时候我们可以在类的内部重新声明为可写的，而对外部仍为只读。但是要注意竞争问题，当我在内部写入的时候，外部正好也在读取，可以通过派发队列来解决。

属性在内部重新声明为readwrite在分类中完成，在公共接口中声明的属性可于此处重新声明，其他特质必须保持不变，而readonly可扩展未readwrite。

但是在对象外部仍可KVC来设置这些属性值。因为KVC会在类中查找set方法，甚至有的人会使用类型信息查询功能在类中查找属性的偏移量，然后直接更改偏移量的值。这些杂技代码都是不可取的。

如果外部需要改变值的话，也尽量不对外声明为可写，而是通过其他方法。比如Person有friends属性，外部可添加删除。
		
	@interface Person: NSObject
	@property (nonatomic, copy, readonly) NSString * name;
	@property (nonatomic, strong, readonly) NSSet * friends;
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends;
	
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	
	@end
	
	#import "Person.h"
	@interface Person()
	@property (nonatomic, copy, readwrite) NSString * name;
	@property (nonatomic, strong, readwrite) NSSet * friends;
	
	@implementation Person {
		NSMutalbeSet * _internalFriends;
	}
	
	-(NSSet *)friends {
		return [_internalFriedns copy];
	}
	
	-(void)addFriend:(Person *)perspn {
		[_internalFriends addObject: person];
	}
	
	-(void)removeFriend:(Person *)persom]n {
		[_internalFriends removeObject: person];
	}
	
	-(id)initWithName:(NSString *)name firends:(NSSet *)friends {
		if(self = [super init]) {
			_name = name;
			_internalFriends = [NSMutalbeSet new];
		}	
		return self;
	}
	
	@end
	
不要在返回的对象上查询类型以确定对象是否可变，在上一例子中，获取方法直接返回了可变对象，这是合理的，因为存储对象可能回很大导致copy操作耗时，所以直接返回，语法上来看NSMutableSet是NSSet的子类，所以也是合理的。

	Person * person = [Peroson new];
	NSSet * friends = person.friedns;
	if ([friedns isKindOfClass: [NSMutabkle class]]) {
		...
	}
	
尽量不要这么做，不宜直接从底层修改数据。

###19.


##第四章协议与分类

###23. 通过委托与数据源协议进行对象间通信

1. 此模式可将数据与业务逻辑解耦 概念

2. 内存管理语义 循环引用
一般使用weak 也可使用unsafe_unretained不过weak在对象释放后会置为nil,而unsafe_unretained则不会。若使用strong则会产生保留环。

3. 权限问题:
如果要向外界公布此类实现了某协议，那么则在接口中声明，而如果这个协议为委托协议的话，那么通常只会在类的内部使用，则在分类中声明。

4. 可选V必须实现
由于协议里的方法不一定都得实现，所以提供了@optional关键字来声明可选方法。既然有可选方法，那么遵守该协议的类就可能不会实现某些方法，那么在使用之前要加个判断
	
	if ([delegate respondsToSelector: @selector(doSomething)]) {
		[delegate doSomething];
	}

调用方法之前先判断该方法是否实现则会避免问题，即便delegate为空也不会发生问题，因为向nil发送消息会返回false。

5. 数据源模式

也可以定义一套接口，从而实现从该接口获取数据。委托模式的这一用法旨在向类提供数据，故而又称"数据源模式"。

6. 协议方法实现以及缓存(位段)

第四点提到调用之前先判断，如果某一方法频繁调用的话，除了第一次检测的结果有用之外，那么后续的每次判断都是多余的，将会影响性能。所以考虑将他缓存起来。
	
	//ViewController.h
	@protocol TestDelegate

	@optional
	-(void)printTest1;
	-(void)printTest2;
	-(void)printTest3;
	
	@end
	
	@interface ViewController : UIViewController <TestDelegate>
	@end
	
	
	//Test.h
	@interface Test : NSObject
	@property(nonatomic, weak) id<TestDelegate> delegate;
	
	
	//Test.m
	@interface Test()
	{
	    struct {
	        unsigned int printTest1 : 1;
	        unsigned int printTest2 : 1;
	        unsigned int printTest3 : 1;
	    } _delegateFlags;
	}
	
	@end
	
	@implementation Test
	
	-(void)setDelegate:(id)delegate {
	    _delegate = delegate;
	    _delegateFlags.printTest1 = [delegate respondsToSelector:@selector(printTest1)];
	    _delegateFlags.printTest2 = [delegate respondsToSelector:@selector(printTest2)];
	    _delegateFlags.printTest3 = [delegate respondsToSelector:@selector(printTest3)];
	}
	
	-(void)create {
	    if (_delegateFlags.printTest1) {
	        [_delegate printTest1];
	    }
	}
	
在相关代码要调用很多次时，值得进行这种优化。而是否需要进行这种优化，具体情况具体对待。

###24. 将类的实现代码分散到便于管理的数个分类之中

方便管理和阅读，在打印的时候回输出分类的信息

一个类中可能会塞满各种方法，然后全部堆在实现文件里，可通过Objective-C的分类机制按逻辑划分到几个分区中。

	@interface Peroson: NSObject
	@property (nonatomic, copy, readonly) NSString ＊ name;
	@property (nonatomic, strong, readonly) NSArray ＊ friends;
	-(id)initWithName:(NSString *)name;

	//Friendship methods
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	
	//work mothods
	-(void)performDaysWork;
	-(void)takeVacationFromWork;
	
	//paly methods
	-(void)goToTheCinema;
	-(void)goToSportsGame;

	@end

	@interface Peroson: NSObject
	@property (nonatomic, copy, readonly) NSString ＊ name;
	@property (nonatomic, strong, readonly) NSArray ＊ friends;
	-(id)initWithName:(NSString *)name;
	@end

	@interface Peroson(Friend)
	//Friendship methods
	-(void)addFriend:(Person *)person;
	-(void)removeFriend:(Person *)person;
	@end

	@interface Peroson(Work)
	//work mothods
	-(void)performDaysWork;
	-(void)takeVacationFromWork;
	@end


	@interface Peroson(Play)
	//paly methods
	-(void)goToTheCinema;
	-(void)goToSportsGame;
	@end

也可以放到不同的文件中。可以创建名为Private的分类，把应该视为私有的方法全都放入这个分类中，这样类的使用者在查看回溯信息时会发现private，然后意识到这是私有方法，不应该调用。


###25. 总是为第三方的类的分类名称加前缀

分类机制通常用于向无源码的既有类中添加功能。分类中的方法会覆盖原有的同名方法，多个分类中的同名方法，最后一个加入的会覆盖之前的。分类中的方法是直接添加到类中的。运行期系统会把分类中所实现的每个方法都加入类的方法列表中。

	@interface NSString (ABC_HTTP)
	-(NSString *)abc_urlEncodedString;
	@end

两个分类重名，虽然不会出错但是会发出重复定义的警告，如果不加前缀，别人的分类和你的重名，在你调用分类的方法时那么可能会发生无法预料的结果。


###26. 