---
title: Effective Objective-C 52 2.0 下
header: Effective Objective-C 52 2.0 下
description: 编写高质量iOS和OS X代码的52个有效方法 下
---

I have to protect the one thing I can't live without.

##第六章 块与大中枢派发

块与GCD都是当前Objective-C编程的基石。因此，必须理解其工作原理及功能。

###37. 理解"块"这一概念

####块的基础知识
块其实就是一个值，与int、float和OC对象一样，赋值给变量。块的语法和函数指针类似。

在声明块的范围内，所有变量都可以被捕获
	
	int additional = 5;
	int (^addBlock)(int a, int b) = ^(int a, int b) {
		return a + b + additional;
	}
	int add = addBlock(2, 5);
	
默认情况下，为块所捕获的变量是不可更改的，可以使用__block使其可更改。块会保留所捕获的对象类型，稍后块被释放时，所有捕获的变量也会被释放。块本身可视为对象。在其他Objective-C对象所能响应的选择子中，有很多块也能响应。块本身也和其他对象一样有引用计数，当最后一个指向块的引用移走之后，块就被回收了，回收时也会释放块所捕获的变量，以平衡捕获时所执行的保留操作。

块定义在Objective-C类的实例方法里中，块可以访问类的所有实例变量以及self变量。块总能修改实例变量，无须加__block。如果通过读取和写入操作捕获了实例变量，那么也会自动把self一并捕获。因为实例变量是与self所指代的实例关联在一起的。

	@interface EOCClass
	
	-(void)anInstanceMethod {
		void (^someBlock)() = ^{
			_anInstanceVariable = @"something";
			//两者是等效的
			self->_anInstanceVariable = @"something";
		}
	}

####块的内部结构

每个Objective-C对象都占据着某个内存区域。因为实例变量的个数及对象所包含的关联数据互不相同，所以每个对象所占的内存区域也有大有小。块本身也是对象，在存放块的内存区域中，第一个变量就是指向Class对象的指针，该指针叫做isa。

最重要的就是invoke变量，这是个函数指针，指向块的实现代码。

descriptor变量是指向结构体的指针，每个块中都有此结构体，其中声明了块对象的总体大小，以及copy和dispose两个函数指针，这两个辅助函数在拷贝及块的丢弃块对象时运行，前者保留捕获的对象，后者释放。

块还会把捕获的对象拷贝一份，这些拷贝放在descriptor变量的后面。拷贝的不是对象本身，而是指针变量。invoke函数需要把块对象作为参数传入块的实现代码中，愿意在于此，执行块时，需要从内存中把捕获变量读取出来。

####全局块、栈块及堆块
定义块的时候，其所占的内存区域是分配在栈中的。也就是说块只在他定义的范围内有效。

	void (^block) ();
	if () {
		block = ^{
			NSLog(@"a");
		}
	} else {
		block = ^{
			NSLog(@"b");			
		}
	}
	block();
	
定义在if及else语句中的两个块都分配在栈内存中。编译器会给每个块分配好栈内存，在离开相应的范围之后，编译器有可能把分配的内存给覆写掉。

为了解决此问题，可给块的对象发送copy消息以拷贝之。这样的话，就可以把块从栈复制到堆了。复制后的块就可以在范围之外使用了，复制到栈的块就成了带引用计数的对象了。后续的复制操作都是递增块对象的引用计数。

	void (^block) ();
	if () {
		block = [^{
			NSLog(@"a");
		} copy];
	} else {
		block = [^{
			NSLog(@"b");			
		} copy];
	}
	block();
	

###41. 多用派发队列，少用同步锁
多线程同时执行一段代码可能会出现问题，GCD之前有两种方法，一种同步锁@synchronize

	-(void)synchronizedMethod {
		@synchronzied(self) {
		}
	}
	
同步锁针对的对象是self，这样能保证每个对象不受干扰的执行这个方法。滥用同步锁会降低代码效率，因为共用一个锁的同步块，必须按顺序执行。频繁加锁，程序有可能会等待一段毫不相关的代码执行完毕才能继续执行。

	_lock = [[NSLock alloc] init];
	-(void)synchronizedMethod {
		[_lock lock];
		//do something
		[_lock unlock];
	}

也可以使用NSRecursiveLock这种递归锁，线程能够多次持有该锁，而不会出现死锁现象。这两种方法都很好，不过都有缺陷，同步块会出现死锁，另外效率也不高，锁对象一旦出现死锁，将会很麻烦。

属性是经常需要同步的地方，需要做成原子的。用atomic来修饰属性，即可实现这一点。而开发者想自己来编写访问方法的话，通常会这样写:

	-(NSString *)something {
		@synchronize(self){
			return _something;
		}
	}
	
	-(void)setSomething:(NSString *)something {
		@synchronize(self) {
			_something = something;
		}
	}

如果有很多属性的话，那么每个属性的同步块都要等待其他属性的同步块完成。这并不是我们想要的。

串行同步队列可以替代同步块或锁对象。

	_syncQueue = dispatch_queue_create("com.effectiveobjective.syncQueue", NULL);
	
	-(NSString *)someString {
		__block NSString * localSomeString;
		dispatch_sync(_syncQueue, ^{
			localSomeString = _someString;
		});
		return localSomeString;
	}
	
	-(void)setSomeString:(NSString *)someString {
		dispathc_sync(_syncQueue, ^{
			_someString = someString;
		})
	}
	
此模式的思路是把读取操作都放入序列化的队列里执行。可以进一步优化，设置方法不一定非得是同步的，设置实例变量所用的块，并不需要向设置方法返回什么值。

		-(void)setSomeString:(NSString *)someString {
		dispathc_async(_syncQueue, ^{
			_someString = someString;
		})
	}

只是把同步派发改成了异步派发，这个小改动可以提升设置方法的实行速度，而读取操作和设置操作依然会按顺序执行，但这个改动在运行时可能会比原来慢，因为执行异步派发是需要拷贝块，若拷贝块的时间明显超过执行块所花的时间，则这种做法将比原来更慢。

多个获取方法可以并发执行，而获取方法与设置方法之间不能并发执行。这次不用串行队列，改用并发队列

	_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	
	-(NSString *)someString {
		__block NSString * localSomeString;
		dispatch_sync(_syncQueue, ^{
			localSomeString = _someString;
		});
		return localSomeString;
	}
	
	-(void)setSomeString:(NSString *)someString {
		dispathc_async(_syncQueue, ^{
			_someString = someString;
		})
	}

目前还不能实现同步，所有读取操作都会在同一个队列上执行，不过由于是并发队列，所以读取与写入操作可以随时执行。而我们不像让这些操作随意执行。此问题用一个简单的GCD功能即可解决，他就是栅栏(barrier)

	void dispatch_barrier_async(dispatch_queue_t queue, dispathc_block_t block);	void dispatch_barrier_sync(dispatch_queue_t queue, dispathc_block_t block);
	
在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。

	_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
	
	-(NSString *)someString {
		__block NSString * localSomeString;
		dispatch_sync(_syncQueue, ^{
			localSomeString = _someString;
		});
		return localSomeString;
	}
	
	-(void)setSomeString:(NSString *)someString {
		dispathc_barrier_async(_syncQueue, ^{
			_someString = someString;
		})
	}



